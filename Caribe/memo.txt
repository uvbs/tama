q#E35ktvhQjnt
addr2line -C -f -e <앱라이브러리.so> <함수 주소>
P4Merge
base: 소스
1st: 소스
2nd: 타겟

장기적으로 해야할것.{
	에버노트 참조.
}
해결해야할 문제{
}


한주를 클리어했을때 뭔가 알림이라도.
오늘의 도전횟수를 다썼을때 캐시로 리셋하기


통합지불모듈 {
  *각종 asset(자원,금화,시간,AP,횟수등)을 캐시로 사는행위의 통합된 모듈
  .UI
    .사려는 asset의 종류와 개수 표시.
	.그 asset의 젬 가격
	.그 asset을 특정 아이템과 교환(AP채움템, 횟수채움템,시간단축템 등)
  .asset의 타입과 개수
  .지불방식(젬, 템)
  .
}


보석매치 {
  .매치시 더미가 걸렸을때만 재접시 시뮬레이션 침공한다.
	.매치시 상대가 더미인지 판별이 가능해야 한다.
  .재접.
	.나랑 매치된 상대가 더미인가.
	  .침공시뮬레이션 가동
	  .가상으로 승패를 내서
		.방어에 성공하면 def만 깎는다.
		.방어에 실패하면 광산주인을 그 상대(더미)로 바꾼다.
}


미노공격력 증가:=> 706(x2)
만족스러운 속도로 적 창병을 제압.
  공격력을 올렸으나 여전히 골렘에겐 상대가 안됨.
  미노탱커를 막는데에는 골렘이 압도적으로 좋다.

상대골렘탱커를 막기
  .창병: 골렘에게 죽지는 않으나 후방 궁수에게 빨리 죽음
  .미노: 가장 먼저 죽음
  .골렘: ...
골렘뒤에 앤트라면?
  .창병: 상대 골렘보다 먼저 전멸함(X)
  .미노: 가장먼저 전멸
  .골렘: 엄청 오래 버팀.

골렘 hp20000
  .창병2정도 남고 승
  .미노 압도적 패
  .골렘: 타임오버
골렘 30000
  .골렘방어보다 미세하게 더 hp가 남음. 시간은 골렘보다 미세하게 더 일찍 전멸




.배치할 위치
.배치할 영웅 or 배치할 유닛
.영웅 레벨, 부대레벨, 스킬레벨
.영웅등급
.특성
.전투시작부터 타이머 가동되어 표시
.부대가 전멸하면 자동 멈추는 옵션
.부대가 전멸하면 버틴 시간 console에 출력

xLegion( 영웅별 특성정보 포함 )
XLegion : 군단정보를 바탕으로 생성
XLegionObj: XLegion을 바탕으로 생성




디버깅용 로그 필터링 시스템 {
  *서버에서 장애가 발생했을경우 CONSOLE등으로 찍은 메시지를 볼수있게 하려함
  *평소엔 로그를 남기지 않게 함(옵션으로 조정)
  *클라도 필요에따라 옵션을 키면 로그가 남게 함.
  *특정유저의 닉이나 idAcc를 지정하면 필터링되어 남김

  로그 필터링 {
	.각 항목의 체크버튼을 on/off함으로써 필요에따라 로그를 남길수도 안남길수도 있게 한다.
	.서버 {
	  .서버는 릴리즈모드라면 필수로그(assert) 이외에는 기본적으로 로그를 남기지 않는다.
	  .하지만 특정항목이 on되어있으면 해당 카테고리의 로그가 파일에 기록되기 시작한다.
	  CONSOLE2("iap", "%s", "hello");		// 태그사용
	  .실행중에 특정 태그를 등록하면 그 태그에 대한 console2()이 호출되었을때 로그를 남긴다.
	  .필요에따라 태그를 다시 지울수 있다.
	  .태그는 .txt파일을 읽도록 하며 리로드 기능을 넣는다.,
	}
}
구글 결제 테스트

1:12~
2:16
3:21
4:26
5:36
6:42
7:48
8:54
9:60



.광산스팟을 열때 전투력이 4~5000 가량됨.
.광산매칭가능한 더미의 최소레벨은 12이고 전투력은 6500가량
.매칭이 안되었을경우 더 큰범위로 확장해서 찾도록 수정.

보석광산 매칭.
  .유저가 없어도 더미로 매칭되도록
  .더미중에서만 매칭되도록 하는 프로시저가 필요함.
	.계정이 더미인지 알 방법이 필요함.(secPlaying이 0)
  .유저를 우선적으로 매칭하고 없으면 더미 매칭


지불 타입 {
  .금화부족
  .ap부족
  .시간
  .자원부족
  .gem부족 => 상점이동
}

소탕시스템 {
  #상대가 유저일 경우 녹색이하만.
  #별3 클리어 한곳
  #소탕권 아이템 소모
  #전투 후 소탕권 아이템 드랍
  #소탕 아이콘
  #소탕후 드랍템 결과
  #소탕 버튼은 항상 활성화 되어있지만 잠김상태를 버튼에 표시
}

apk  만들어 보고
약 40~50메가 선에서 apk만들수 있도록 패킹목록 다시 정리
클라에서 패치받을때 update1.txt를 받는다면 여기서 apk_list.txt에 있는것들은 걸러내고 받는다.

전체 리소스중 apk절반, 패치 절반의 경우
* 최초 받는 유저
  .update1.txt에서 apk_list에 있는건 거르고 받는다.
  .현재 update100 이라면 모든파일을 다시 받을가능성도 있다.
  .다시 받지 않으려면 lastUpdate.txt를 가지고 있어야 함.
  .lastUpdate.txt는 무조건 있어야 함. 안그러면 최초실행시 1~100까지  목록 전부를 받게 됨.
* LastUpdate가 있을경우.
  .패치받을 절반의 파일은?
  .apk에 lastUpdate=100, 최신 패치는 103일경우
  .최초패치시 apk_list를 제외한 모든 파일을 full_list에서 받음.
  .101~103패치를 추가로 받음.(최초엔 위와 합쳐서 한꺼번에 받음)
  .최초패치란? full_list파일이 워크에 있는지 없는지.
  .lastUpdate가 아예 없을경우 경고.만약 사고로 인해 없어졌다면 full_list를 받아서 모든 파일을(apklist포함)다시 받는다.
* lastUpdate가 없을경우 full_list를 받아서 apk_list를 제외한 파일들을 다운받고
  .lastUpdate를 갱신한다.
* apk를 만들때 lastUpdate파일의 자동화 이슈
  .패치를 한후 생성되는 lastUpdate파일을 카피(MakePackage와 같음)
  .lastUpdate파일을 수동으로 만들땐?
	.현재 올라가있는 lastUpdate의 버전값을 지정.
* apk를 만들고 난 후 다시 패치가 추가되었을때
  .apk의 lastUpdate버전이 낮을테니 모자란부분은 추가로 받게됨.
.만약 실제 apk에는 포함되었으나 apk_list에는 누락된 파일이 있다면?
	.full_list에 의해 새로 받게 됨.
.apk_list에는 있는데 apk에는 파일이 없다면.
	.에러남.
	.full_list실행시 apk_list파일들이 apk에 모두 있는지 검사해서 없는건 경고 띄우고 다운목록에 포함시켜야함.
	.assets으로 복사할때 복사완료후 거기서 apk_list를 자동으로 만들어야 실수가 없다.
	.따라서 apk에 들어가는 파일들을 결정하는건 bat파일에 포함되는지 여부이다.
정리
 *apk와 패치를 절반으로 나눌때 프로세스
 *apk를 만들때 필수 파일
   .lastUpdate.txt
   .apk_list.txt(assets으로 bat카피후 자동으로 생성시켜줘야함)
   .lastUpdate를 수동으로 넣어야 한다면 최신 lastUpdate를 넣는다.
   if( 앱실행시 work에 full_list가 있는지 확인 ) {
	// 최초 패치.
	.full_list를 요청해서 받는다.
	.apk_list와 비교해서 없는것만 다운목록에 추가시킨다.
   }
   .lastupdate를 요청해서 받는다.
   .패치받아야할 목록이 있다면 updateXX파일을 받아 목록을 만든다.(full_list로 뽑은 목록과 합침)
   .목록을 다운 받는다.
   .lastupdate파일을 업데이트 한다.
   .full_list실행시 apk_list파일들이 apk에 모두 있는지 검사해서 없는건 경고 띄우고 다운목록에 포함시켜야함.(apk_list생성자동화가 안되었을경우)


*work의 lastUpdate보다 apk의 lastUpdate가 버전이 더 높아도 work를 기준으로 하므로 다운을 다시 받는 문제.
  .패치받아야 하는 목록을 받아서 이것을 패치서버로부터 받는게 아니라 apk로부터 재 카피해야한다.
  if( lastUpdate(apk)버전 > lastUpdate(work)버전 ) {
	work_ver ~ apk_ver까지의 패치목록을 받는다.
	이 패치목록의 파일들을 apk로부터 패치(카피)한다.

	패치서버 ver5
	apk ver4
	work ver3 의 경우
	4버전은 apk거를 받은 후 5버전은 패치로 받는다.
  }



v1,v2,v3,v4
ANGs = 180
RsGsBs -> HsSsLs  로 변환
ang = ANGs;
if( v1 <= H >=v2 ) {
	ratio = (Hs - v1) / ( v2 - v1 );
	ang *= ratio;
}
HsSsLs += ang;











아이디 등록하고 등록된 아이디 리스트 볼수 있는 UI(혹은 콘솔에 출력)
태그 등록하고 등록된 태그 볼수 있는 UI(혹은 콘솔에 출력.)


최초 로그인서버 연결되면 로그인정보 보내기전에 프로퍼티 데이터부터 요청한다(sessionkey 없을때)
프로퍼티 데이터 다 받으면 로그인정보 요청한다.


월정액 구현 {
	저장시에는 지급한 횟수, 다음지급해야할 시간
	최초 구매시에 1개를 지급받고 다음 지급받아야 할 시간을 기록한다
	다음 로그인때 현재시간을 읽어서 다음지급시간을 넘어섰으면 오프라인일수를 1개올린다 그리고 24시간을 더한다
	위를 반복한다
	다음지급시간이 안되었으면 pROCESS()에서 1분마다 체크한다
	지급시간이 지났으면한개 지급하고 카운터 빼고, 다음 지급해야할 시간을 지정한다
	로그인시 오프라인일수가 있으면 그만큼을 반복해서 지급한다
}


첫 구매시 받는 캐시 적용?
30번이 정확하게 지급되는지?
월정액상품기간중에 다시 월정액 못사게
우편 UI수정
서버에서 운영자 공지 & 선물 보낼수 있게.

빌드버전 관리 {
  apk {
	.192번 접속용(_X192)
	.gmo접속용
	.local서버 접속용
  }
  서버 {
	.개인개발용
	.192번용(_XNOT_BREAK)
	.GMO용
  }
  옵션 {
	결제 {
	  .softnyx
	  .google
	}
	패치

  }
}



렌더링 최적화 전략
{
  .draw콜을 최소화 해야한다.
	.이를 위해서는 몰아찍어야 한다.
	.텍스쳐 한번 전환시 최대한 많이 찍어야 한다.
	.스프라이트 찍기 우선순위가 있기때문에 z버퍼가 필수가 된다.
	.z버퍼가 작동하려면 모든 스프라이트들의 깊이좌표가 있어야한다.
	.투영은 평행투영으로 한다.
	.
}







유닛간 메시지교환 방식으로 변경
.데미지주기
  .직접 상대유닛의 hp를 깍지 않고 메시지만 던진다.
  .받는측은 받은 메시지들을 모두 한꺼번에 처리한다.
  .한턴에 두명으로부터 데미지를 받았다면 데미지준 상대와 데미지양을 두번다 받아놓고 자기차례에서 그것들을 차례로 꺼내 적용한다.
.피드백
  .데미지를 주고 그 결과를 공격자가 바로 알아야 하는경우
  .피드백도 다시 피격자가 공격자에게 메시지를 날려야 한다.
  .
메시지의 종류
  .데미지
  .밀어내기
  .버프걸기
  .
메인루프
{
	objMng->FlipQ();			// 메시지큐 플립
	objMng->SprFrameMove();		// SprObj의 frameMove. 키 이벤트발생
	objMng->ProcessMsg();		// 메시지큐 처리.쌓인 메시지를 처리하고 다시 다른 객체에게 메시지를 전달한다.(이중버퍼를 둬서 다음프레임에 처리하도록 한다.)
	objMng->ProcessAI();		// AI가 객체에게 명령
	objMng->ProcessMove();		// 명령을 수행함.
}


일주일간 해볼만한일
{
  .각 유닛들의 특성살리기
  .영웅 스킬 만들기
  .렌더링 최적화
  .전투씬 UI(좌우측 영웅리스트 + 타격감)
  .용량 최적화
}


툴팁시스템 {
  * layout에서 제어
  * 버튼이나 wnd혹은 image등 영역이 있는 모든 컨트롤을 클릭시에 레이아웃이나 툴팁을 뜨게함.
  * 텍스트만 있는 간단한 툴팁은 "tooltip"항목을 추가해서 텍스트 id를 지정
  * 말풍선은 3x3 이미지를 사용

  .보정값을 넣을수 있어야 함
  .이미지도 함께 넣을수 있도록 자유롭게 되어야 함.
  .버튼형태 툴팁도 지원

  
}

멀티샷 폭발 sfx수정

터치하면 헬프 툴팁뜨는 시스템
씬 UI테스트할수 있는 시스템
보스퀘 + 지역오픈.



삭제된 파일의 패치전략
{
  .full_list를 받는다.
  .현재 work폴더의 풀 리스트를 받는다.
  .work폴더의 풀 리스트의 파일들을 하나씩 full_list.txt와 비교한다.
  .full_list에 없는것은 삭제된것이므로 파일을 삭제한다.
  .이를위해서는 순수 Resource폴더만 필요하다.
  .일단 시간오래걸릴거 같으니 영문모드ui가 잘못나오면 앱을 지웠다 다시 깔도록 유도
}

GMO서버 패치 다운로드 속도(사내WiFi로)
193번 서버 패치다운속도 ( LTE로)


패치씬
  .오프닝 출력시 터치하세요 메시지 빼기
  .앱 최초 실행 다운로드가 아니면 오프닝 플레이 하지 않기
타이틀
  .계정생성중이거나 팝업이 떠있으면 오프닝 실행하지 않기
  . 터치하세요 메시지 빼기


 FSM을 멈춰도 로긴서버에서 소화하는속도가 너무 느리다.
 왤까....?
 1.DB억세스가 느려서.
   .로긴서버는 DBMNG의 sleep을 10으로 주고 있음
   .DB억세스는 두가지. 
	  .첫번째는 Login서버에서 직접 DB를 뒤지는것(UUID로 idAcc찾기)
	 .두번째는 GameSvr/DBA서버에 의뢰해서 받아오는 시간
	 .둘중에 어느것이 느린것인가.
DBMNG의 result처리가 메인스레드에서 처리되므로 메인스레드의 초당프레임수에 맞춰서 send를 한다.
이것만 빨리 소화되도 상당부분 부담을 줄일 수 있다.
그렇다면 초당프레임수가 적게 나오는 이유는?
XClientConnect의 Process()중 Lock()의 대기시간이 길다.
spConnect에 락을 거는곳은?
XEWinSocketSvr::WorkThread
XEWinSocketSvr::Acceptthread
DBMng2::WorkThread()
acceptThread는 최초 한번 생성할때 외엔 재차 락을 걸일이 없기때문에 제외
WorkThread는 해당 커넥션에서 패킷이 왔을때 Lock을 검. 그러나 클라가 로그인요청해놓고 다시 패킷을 보내는일은 없지 않은가.
DBMng::WorkThread. spConnect->Process()에서 RecvXXXX류를 해서 패킷을 뽑은 후 DoAsyncXXX를 통해 DBMNG에 의뢰
의뢰를 던져놓으면 결과가 나올때까지 기다려야 하므로 사실상 락을 걸고 있을 필요가 없다.
다시말해 패킷큐에 패킷이 쌓여있지 않으면 락을 걸고 있을 필요가 없다는 뜻이다.
DBMNG Work스레드에서 spConnect에 Lock을 걸고 있으면 DB작업이 끝날때까지 메인스레드의 spConnect->Process()는 멈춰 있게된다!

PurchaseInfo(type:null):{"returnCode":"0","point":"0","paymentToken":"d6ff798f7fdd546901fef3ec5c0fff3a9bea3372b9044294b60dc12492576f","orderID":"10961"}
PurchaseInfo(type:null):{"returnCode":"0","point":"0","paymentToken":"b308e98c05326c461aea7fc28d7aa4f0cf67ba7fe3ec4f32bbe5d5a014f200","orderID":"10962"}
소프트닉스 스토어는 소프트닉스 캐시를 사는곳인듯 하다
스토어충전 -> 소프트닉스캐시 -> 젬 -> 인게임사용
구글스토어(현금) -> 젬 -> 인게임사용

소프트닉스 스토어에서 미리 캐시 충전
인게임 상점에서 캐시xxx개당 젬 xxx개 구입
  .젬구매 클릭 => 상품명 서버로 전송 => 서버에서 받아서 페이로드발급과 함께 DB에저장 => 클라로승인+상품명(+payload?)
  .서버승인->클라->Softnyx로 상품명과 캐시가격을 넘김
  .구매완료(파일이나 레지스트리에 구매완료정보를 써둠:ex) pay001.txt )
  .(여기서 클라가 죽으면? 구매완료토큰을 파일이나 레지스트리에 저장해두지 않는다면 복구할 방법이 없다.)
  .(만약 클라가죽었다면)
	.재 로그인시에 구매완료파일(payXXX.txt)를 읽어 order_id와 token을 보냄
  .구매완료 정보(order_id, payment_token) 서버로 보냄
  .구매정보로 post검증
  .구매하려했던상품명 => 젬 지급 => 승인 => pay파일 삭제

OnClickBuy() {
  SendReqBuyItem( idsProduct ) []( payload, idsProduct, price ) {
	// payload는 계정아이디로 사용
//	writeFile( payload, idsProduct, price, orderId="", token="" )  거래가 이뤄지지 않았다면 파일에 저장하는게 의미가 없음. 거래하기전에 클라가 죽었다면 서버에 payload가 지워지지 않고 남아있는 문제는 있음.
	JniHelper::SoftnyxBuy( idsProduct, price, payload ) [](orderId, token, payload) {
		file write or registry write 
		  . writeFile( payload, idsProduct, price, orderId, token );
		  .idsProduct, order_id, token; pay.txt안에 리스트로 작성하는것도 좋음.
		SendReqPurchasedItem( payload, idsProduct, price, order_id, token ) 
			[] ( payload, numGem, errCode ) {
				// 구매 최종완료(스토어캐시는 동기화가 완벽하지 않기때문에 서버에서 보관하지 않음)
				if( errCode == Ok ) {
				  ui갱신, gem개수 갱신
				  pay.txt에서 payload로 검색해서 삭제.
				} else
				if( errCode == 실패 or 중복검증 or 결제확인시간초과 ) {
				  pay.txt에서 payload로 검색해서 삭제.
				} else
				if( errCode == -99 ) {
				  pay.txt남겨둠
				}
		}
	}
  }
}
=============================
server
RecvBuyItem( idsProduct ) {
  CreatePayload( payload="계정번호", idsProduct )
  SendBuyItem( payload, idsProduct, price );  // payload는 구매요청 고유아이디개념
}
// 구매완료후 지급요청
RecvPurchasedItem( payload, idsProduct, order_id, token ) {
  if( LoadPayload( payload, &idsProduct ) ) {
	// payload찾음
	SendHttpPost( order_id, token ) []( returnCode, price ) {
	  // http 검증완료
	  if( returnCode == ok ) {
		DelPayload( payload );
		m_numGem += idsProduct.numGem;
		SendPurchasedItem( payload, m_numGem )
	  } else
	  if( code == 실패 ) {
		SendMsg( 잘못된 거래입니다. ) // token불일치인듯.
	  } else
	  if( code == 중복검증 ) {
		SendMsg( 없거나 종료된 거래입니다 )
	  } else
	  if( code == 결제확인 유효시간 지남 ) {
		SendMsg( 거래유효시간이 초과되었습니다. 고객상담실에 문의바람 )
	  } else
	  if( code == 응용프로그램에러-99 ) {
		SendMsg( 거래시스템장애. 재로그인시에 다시 시도 )
	  }
	}
  } else {
	// payload찾을 수 없음.
  }
}


.무한 온라인으로 했는데 끊어지는 애들이 있는지 카운팅
.모두 온라인 했는데 게임서버에서 DBA로 뭔가를 계속 보낸다. 뭔지 확인




새 씬생성시 직관적인 생성단계 {
  .공 씬을 하나 만든다.
  .기본 레이아웃을 지정한다.
  .어디로부터 호출되며 어디로 나가는지 지정한다.
}


의문.
1. 왜 LoginSvr => GameSvr로 보내는 건수가 저거밖에 안될까?★ <- 이게 일단 가장큰 문제
  DB에서 UUID검색하는 평균fps를 구해봐야 할듯. 이 속도가 ToGameSvr의 속도와 비슷하다면 문제는 DB억세스가 느려서이다.
2. GameSvr <=> DBASvr간의 avgLoad속도도 이제 빨라졌다. 그런데 왜 봇쪽에서의 평균 로그인속도는 줄어들지 않을까.
3.send()를 쓰고 있는 XSocketClient가 영향을 주는것일까.
4.클라 로그아웃시 DBA에서 미처 저장을 다 못했는데 다시 로그인하면 어떻게 되지?





로긴서버 블로킹 현상
.DBmng의 spConnect의 락과 XWinSocketSvr::Process의 spConnect락이 서로 경쟁하면서 DBMNG에게 밀리면
메인스레드가 지연되면서 블로킹이 걸린다.
둘간의 발란스를 어떻게 맞출지 연구해야한다. ::Process를 메인스레드에 두지말고 별도의 스레드에 두는것도 한방법
적어도 메인스레드에 블로킹이 걸리는일은 없으니까.
.메모리풀로 하니까 오히려 블로킹 현상이 더 자주나타나는 느낌 -_-;;;
상용메모리풀과 속도 비교
큐 푸쉬 펌핑시 블럭단위로 넣고 빼는 최적화
XQueueArray와 std::queue속도 비교

어차피 Logined리스트가 꽉차면 블로킹 걸리는건 매한가지.
1.큐를 4바이트나 8바이트짜리로 바꾼다.
2.아니면 메모리 블럭 단위로 큐를 밀어넣는다.(O)
3.패킷 펌핑을 멀티스레드로...(위험부담이 좀 있음)
4.2000개 연결에서 패킷 1개씩 펌핑하는게 그렇게 오래걸리나????????

메모리풀 동적으로 늘어나도록.
블로킹이 오래걸리면 게임서버가 죽지도 않았는데 로그인서버에서 게임서버의 연결이 끊어진다.
아마도 허트비트 때문이 아닌가 싶다.
로그인서버에서 감당하기 힘든수의 접속이 들어오면 잠시 대기하도록 다시 돌려보내는 패킷이 필요할듯 하다.
애초에 장시간 블로킹이 걸리는일이 없어야한다. 서버가 죽은줄 알고 런처가 죽여버린다.

DBA서버에서 패킷이 계속 쌓이는걸로 보아 부하가 많은듯(Release)
최대 클라이언트 접속 한계



idAcc의 번호끝자리를 게임서버에 대응되게 해놨는데 이거ㅑ 무시하고 해도 될지 검토중
{
  .게임서버에 접속하면 접속한 게임서버의 아이디(idLastConnectSvr)를 DB에 저장한다.
  .정상종료시 idLastConnectSvr를 0으로 DB에 저장한다.
  .만약 같은계정으로 누군가가 접속해있다면 idLastConnectSvr는 0이 아닌값이 들어있게된다.
  .후에 들어온 유저가 DB를 읽었을때 idLastConnectSvr가 0이 아닌값이면 누군가가 이미 접속해있다는 뜻이된다.
  .기존유저를 정상종료시키며 idLastConnectSvr를 0으로 만든다.
  .후 유저가 다시 접속하면 idLastConnectSvr가 0이되어 정상접속한다.
  .처음으로 반복.
}





24(목)/25(금)
신분증
통장사본
IRP내역
급여통장 거래내역









인앱 해킹방어 {
 *검증에 통과했던 영수증과 시그니처를 다시 보낸다.
   -현재: 페이로드가 존재하고 영수증가 시그니처과 일치하므로 통과된다. => 중복구매를 방지해야함.
   -개선: 구매완료됐던 영수증을 DB에 저장해두고 이미 있는 영수증이면 실패로 돌려야 한다.
 *퍼블릭키를 털어서 임의의 영수증을 위조한다.
   -페이로드를 클라에서 만들수가 없으므로 실패함.
   -이미 구매했던 페이로드를 붙여보낸다면...
	 .페이로드와 영수증쌍으로 비교해서 다르면 실패로 처리해야한다.
 *A상품을 살거다 라고 하며 새 페이로드를 발급 받은 후 임의의 위조된 영수증을 만들어 새 페이로드를 붙여 보낸다.
   -앱서버에선 방법이 없음.
   -구글서버에 진짜 구매한건지 조회 해야함.
 결론: publicKey가 털리면 어떤짓을해도 다 털린다.
}

영수증 중복 검사를 위한 준비 {
	from client:
		-original Json
		-Signature
	Json sample
		orderId : "GPA.1323-8171-3401-29065"
		packageName : "com.mtricks.caribe"
		productId : "inapp_cash00001"
		purchaseTime : 1456728561530
		purchaseState : 0
		developerPayload : "58281C8F977B4FFAA35B75687CE8A2FF"
		purchaseToken : "nncdakdlhamfmfenmdmkfppm.AO-J1OwUMeCm6pxBRGSDnPCL7N49W9D3mhQgsHSxyR0k0WjE2ajzqpJEDF6afhh0qtB7rHEtpBqbn3tuANbvKlEkzfb7aDJEUCbpq4y-CA04CvqPQKkIhxPKpeUmsmj7avbOliWVSnbN"
	http검증에 필요한 요소
		.productId
		.purchaseToken
	DB에 보관해야할 요소(계정별)
		.productId
		.purchaseToken
		.access Token(?) - 1시간동안만 사용할수 있는 그 토큰
	프로세스
}
중복검증 프로세스 {
클라가 구매를 한 후 승인요청( json, signature )
{
	if( 발급한 페이로드로 구입한 영수증인가 ) {
		승인 = Ok;
		DB에서 페이로드 삭제;
		// 만약 소진에 실패해서 json이 한번더 올라오더라도 페이로드가 없으므로 적용되지 않음.
	}
	
}
}



비주얼적 요소 정리
{
미완성 UI모두 완성
연구전확인창
군주 레벨업
훈련/연구가 끝났습니다
사운드
전투중 사운드
파티클 효과
	.전투후 월드맵에서 자원 줏어먹기
	.스팟에 쌓인 자원 수거시 팍터지며 바닥에 떨어지고 줏어먹는 방식
	.자원파티클 날아가는 효과 수정
애니메이션 효과
로딩중 애니메이션
전투
타격감
스킬 사용 연출 보강
크리티컬 데미지 숫자
월드맵

}
apffkflrjs@gmail.com,
aygandalf@gmail.com,	
jakwho1980@gmail.com, 	
jungwan1234@gmail.com,	
kareissma@gmail.com,
nidboss@gmail.com,
osg1127@gmail.com,
romantotoro@gmail.com,
sb1024ey@gmail.com,
sjy875211@gmail.com,	
whrudska234@gmail.com,
xuzhu@mtricks.co.kr,	
yaungi01@gmail.com,	
zitnbada@gmail.com
<정복자들:혼돈의 바람> 앱의 테스터가 되셨습니다.
아래의 주소로 들어와 테스터참여를 수락한 후 apk를 다운로드 받으시길 바랍니다.
만약 실행이 안되거나 접속이 안될경우 기존앱을 삭제 후 설치해 주시기 바랍니다.

https://play.google.com/apps/testing/com.mtricks.caribe
gcm_regid등록 {
	새계정생성시 {
		deviceid를 현재 보내고 저장하고 있으므로 더이상 처리할것 없음.
	}
	기존계정 {
		앱버전이 변경되면서 자동으로 regid를 새로 만든다. 
		콜백매니저에서 regid를 받아서 메모리에 올려두고
		겜서버 로그인까지 끝나면 다시 보내서 저장하게 한다.	
	}
}


attempt to get byte primitive array elements with an object of type int[]
전투중 자원부대 죽이면 자원아이콘 튀어나와서 주워먹는거
개인레이드.


특성초기화 {
  .영웅별로 초기화가 이루어진다
  .연구소 우측패널에 특성초기화 버튼이 배치된다.
  .누르면 비용을 안내하는 확인창이 뜬다.
  .초기화를 하면 모든 유닛에게 찍은 특성포인트 합산해서 돌려받고
  .잠금해제 포인트를 따로 받는다.
  .유닛들의 특성포인트와 잠금해제 정보는 초기화 한다.
  .특성초기화 버튼이 있던자리는 버튼이 사라지고 받은 포인트가 표시된다.
  .여분특성포인트가 있으면 자원이나 금액을 사용하는 대신에 포인트를 우선적으로 사용한다.
  .여분 포인트가 없다면 다시 초기화 버튼이 나타난다.
  .다음 초기화 비용은 50%씩 증가한다.
  .최초 초기화비용은 무료다.
  .초기화 아이템이 있다면 비용창이 뜰때 버튼이 하나더 추가된다.

}



1024이상 이미지 로딩전략(예:2048)
일단 파일은 통째로 로딩
1024가 넘어가는 서피스생성요청이 들어오면 1024단위로 나눠서 생성
버텍스는 1024단위로 가로2,세로2로 생성
텍스쳐는 1024단위로 4개를 생성
텍스쳐 바꿔가며 4번 찍어야 하나?
쉐이더내에서 4패스한꺼번에 넣어서 못하나?




안쓴사운드
common_get_item			// 전혀 어울리지 않음
common_hero_levelup		// 어울리지 않는것 같은데 한번더 확인
common_progress
sample01
sample02				// 뭔가 알림소리로 어울리는듯.
tech_skillup			// 전혀 안어울림. 타격음 같음.
tech_unlock				// 얼추 어울리는것 같지만 좀더 기쁜(?)소리였으면 좋겠음.
world_quest_new			// 안어울림. 일단한번 넣어보고 다시 판단
world_quest_reward		// 퀘보상 별터질때 함 써보자
world_remove_cloud		
world_spawn_spot
버튼클릭_버튼형태가아닌UI의누를때소리.wav
월드맵 환경음 시리즈
전투관련 음들

01-29 16:40:45.693: E/KeyHash:(25545): oSoRAZF05sQS10Sf5a/OZgCxKn4=
1385798771667701

효과가 안좋은 사운드
battle_defeat.wav		// 배경음에 묻힘
battle_victory			// 배경음에 묻힘(오히려 훈련완료에 쓰는게 나을듯)
butt_normal				// 찰칵하는 소리가 맘에 안듬(좀더 부드러운 소리였으면.)

배경오브젝트 계획 {
	propObj.xml에 배치
	일단 시작시 모두 로딩
	프로세스 안에서 현재 맵의 보이는 영역을 검사해서 범위내에 들어오는 오브젝트중 아직 생성안된건 생성시키고
	이미 생성된 리스트에서 범위밖에 있는건 삭제
	물반짝이 같은건 덩어리 타입을 몇개 만들어 놓고 써야 할듯

}


소켓객체 구조 개선
{
	.헷갈리므로 적어도 클라에선 커넥트와 리커넥트의 개념이 필요없다.
	  .게임 재접속 개념은 세션키로 한다.
	.Connected개념과 ReadyForServer의 개념을 분명히 한다.
	  .Connected는 low단에서 ::connect()가 성공했다는 의미. protected로만 사용한다.
	  .ReadyForServer는 Connected된 후 서버로부터 CONNECT_COMPLETE패킷을 받으면 on이 된다.
	  .게임단에선 ReadyForServer만 사용한다. 
	   다시말해 Connected가 되었더라도 ReadyForServer 가 안되면 연결이 안될걸로 간주하고 타임아웃이 되면 소켓닫았다가 다시 연결을 시도한다.
	  .DoDisconnect의 개념을 분명히 한다. 
		.DoDisconnect()는 클라측에서 능동적으로 끊을때.
		.서버측에서 끊었을때는 OnDisconnectedByExternal를 발생시키고 CloseSocket()과 ClearFlag계열을 사용해 초기화 한다.
		.DoDisconnect()로 끊었을때는 OnDisconnectByClient를 발생시킨다.
		.DoDisconnect()로 끊었을때 work thread에서 OnDisconnect가 다시 발생하지 않도록 work thread를 먼저 닫아준후 소켓을 닫는다.
	.소켓은 연결이 다시 이뤄질때마다 새로 생성되므로 소켓객체가 생성되는 시점에선 생성하지 않고 연결이 시작되는 시점에서 생성한다. 
	.클라는 XENetworkConnection과 XSockClient를 독자적으로 쓴다.
	 .XENetworkConnection을 따로 분리 시켜놓을필요 없으니 둘을 합치는게 심플하다
	 .과거 이걸 분리시켰던 이유는 서버와 코드를 함께 쓰기 위함
	 .한가지 걸리는건 자동 봇을 만들때 혹시 필요하지 않겠냐는 것이다.
	   .봇을 옛날방식으로 소켓을 시뮬레이션 하는식으로 만들면 너무나 복잡해진다.
	   +.한 프로세스에서 개별 봇클라를 생성시키고 그들이 독자적인 소켓으로 서버에 접속한다면 봇수만큼 소켓이 생성되어야 한다. 가능한가?
}

중복접속유형(DB lastconnectsvrid에 값이 있는경우)
{
	다른기기에서 내 계정으로 접속되어 있음 {
		User객체가 있음
		  . User객체에게 DuplicateConnect보내서 끊게함.(유령객체일수도 있으므로 여기에 의존하면 안됨)
		  .UpdateLogout시킴. =>? 다시 게임서버로 돌아와서 여전히 남아있으면 강제 삭제.
			-의문: 중복접속패킷보내고 서버에서 강제로 끊으면 클라는 받을 수 있는가.
			  만약 못받으면 서버에선 언제 끊어야 하는가.
			  실제유저인경우 
				클라에서 끊게하고 클라가 못보내는상황이면 2차보완으로 서버에선 하트비트만 체크해서 끊는방법 => 
			  유령인경우
				클라에서 끊지 못하므로 하트비트로 끊어짐. => 새 유저는 유령이 사라질때까지 계속 재접을 시도함.
			  어찌됐건 클라에서 끊어주지 못하면 유령이 사라질때까지 새 유저는 계속 재접만 시도함.
			.
		이미 접속되어있는 유저를 강제접속해제 시킴.(로그아웃되며 lastsvrid는 0이됨)
		새 접속유저는 1초후에 재 로그인.
	}
	실제 접속한 유저는 없는데 유령유저가 서버에 남아있음 {
		유저 삭제
		정상로그아웃 처리시킴(lastsvrid를 0으로)
	}
	유저객체가 없음(정상로그아웃을 못해서 제대로 클리어를 못했음) {
		정상로그아웃처리 시킴.
		새 유저는 끝나면 재접.
	}

}


페이스북
{
	최초로그인시
	  -uuid+닉네임
	  -id+pw
	  -facebook 
		if( 인증에 성공 ) {
			fb userid를 서버로 보냄;
			if( fb userid가 등록되어있는가 )
				로그인정보 보냄
			else
				서버에서 uuid를 생성해 db에 uuid + fb userid를 저장 후 새계정 생성
				로그인정보 돌려보냄;
			담부턴 fb userid로 로그인
		} else
			진입불가
	평소로그인
	  -uuid
	  -facebook
		if( 인증성공 ) {
			fb userid를 서버로보내 로그인정보 돌려보냄.
		} else
			로그인불가
	플레이중 계정등록
	  -id+pw
	  -facebook
		if( 인증에 성공 ) {
			facebook userid전송. 그다음 로그인부터 페북userid로 자동 로그인
		} else
			등록실패
	프로필사진 관련
	 -페북으로 로그인하면 서버에선 유저의 fb userid를 보관
	 -유저 본인은 클라단에서 자기 프로필사진을 요청해 받을 수 있음
	 -새 성스팟이 매치되면 fbuserid를 함께 받고 클라단에서 요청해서 프로필사진을 받아 성에 띄움.
	   .요청할때 유저의 idAcc값도 jni로 보냈다가 받을때도 그걸 다시 받아야 한다.
	   .혹은 요청한 fbuserid를 키로한 맵을 구성해놓고 idAcc를 검색해서 얻는다.
	UI {
		최초로그인 {
		  .계정을 이미 가지고 있습니까? 
			.YES -> id/pw 계정생성 + 로그인
			.NO -> UUID 계정생성 + 로그인
		  .Facebook버튼
			.인증성공 -> fb userid전송 -> 자체uuid생성+fb userid등록으로 계정생성 + 로그인
		}
		평소로그인 {
		  .login.txt를 참조해서 자동 로그인
		  (페북 인증안되면 게임 못하는건가?)
		  if( 페북 인증안되면? ) {
			.UUID로그인을 시도하시겠습니까?
		  }
		}
		플레이중 계정등록 {
		  .페북 등록 버튼 => 인증성공후 => 페북연결완료 버튼으로 교체
		  .이후부터 페북로그인되어 있으면 페북연결완료버튼이 떠야함
		  .페북 연결끊기를 지원해야 하는가. 연결끊기를 하는 이유는 뭐지? 프로필사진 감추기 위해?
		}
	}
	문제점 {
		.일반적인 게임들은 페북을 연결시킨다고 해서 로그인할때마다 페북 인증을 받지는 않는다.
		 다시발해 uuid나 id/pw로 로그인을 하면 메인 로그인은 이걸로 되고 페북이나 구글은 접속하든지 안하든지 옵션일뿐이다.
		.그러나 에픽의 사례에서 보듯이 외국퍼블리셔는 페북 로그인을 반드시 요구하는 경향이 있다. 이러면 원빌드버전이 안되는데 어떻게 해결할것인가.
		.페북 로그인만 원하는 경우
		.페북 로그인과 자체 로그인을 원하는경우
		.자체 로그인만 원하는 경우
		.게스트접속을 원하지 않는경우(태국 병신들은 첨에 원하지 않는다고 해서 고쳐줬더니 다시 게스트모드 넣어달라고 병신짓함)
		.페북인증을 요구하는경우 계정등록시 최초한번만 하고. 그담부턴 uuid로 로그인하도록 내부에서 바꾸면 된다. 눈치까면 다시 고쳐주든가....음
		.

	}

}
페이스북(fb userid를 uuid로 사용하는 방법)
{
	최초로그인시
	  -uuid+닉네임
	  -id+pw
	  -facebook 
		페북로그인 버튼 누름.
		if( 인증에 성공 ) {
			fb userid를 uuid로 서버로 보냄 + 페북로그인 flag;
			if( uuid(fb userid)를 검색 == 있는가 )
				로그인정보 보냄
			else
				uuid(fb userid)로 새계정 생성
				로그인정보 돌려보냄;
			담부턴 uuid(fb userid)로 로그인
		} else
			진입불가
	평소로그인
	  -uuid
	  -facebook
		if( 인증성공 ) {
			fb userid를 uuid로 해서 서버로보내 로그인정보 돌려보냄.
		} else
			로그인불가
	플레이중 계정등록
	  -id+pw
	  -facebook
		if( 인증에 성공 ) {
			fb userid를 서버로 보냄
			if( fb userid를 별도의 항목에서 검색 == 있음 ) {
				등록실패를 보냄
				이미 등록되어있는 계정임. 등록되어 있는 계정으로 데이타를 바꿀까요?
			} else {
				1.현재 사용중인 uuid와 별도로 fbuserid를 보관
				2.uuid자체를 fb userid로 교체(가능함?)
				등록완료 패킷 보냄.
			}

		} else
			등록실패
}
[Access-Control-Allow-Origin: *, Content-Type: image/jpeg, X-FB-Trace-ID: DJN3Ea4asnl, X-FB-Rev: 2132664, Pragma: no-cache, Location: https://scontent.xx.fbcdn.net/hprofile-xpf1/v/t1.0-1/p200x200/10850152_887515704600895_7869967517295922507_n.jpg?oh=0a6449714a6cf57f9a5d8c1eb615e92a&oe=5705456D, Cache-Control: private, no-cache, no-store, must-revalidate, Facebook-API-Version: v2.0, Expires: Sat, 01 Jan 2000 00:00:00 GMT, X-FB-Debug: LTjmXOGnoXhF64V/swyk3EE7eNroa8yfQfBQSaPJKAiWfQccfoN10tcO9Fd20KcKbT4X3GnhDUUyfoi/Hw5x9Q==, Date: Tue, 19 Jan 2016 09:27:06 GMT, X-Cache-Ts: 1453195626, Connection: keep-alive, Content-Length: 0, null, null]
[WWW-Authenticate: OAuth "Facebook Platform" "invalid_request" "(#100) type must be one of the following values: thumbnail, album, normal", Access-Control-Allow-Origin: *, Content-Type: text/javascript; charset=UTF-8, X-FB-Trace-ID: GrIsLfT9r9+, X-FB-Rev: 2132664, Pragma: no-cache, Cache-Control: no-store, Facebook-API-Version: v2.0, Expires: Sat, 01 Jan 2000 00:00:00 GMT, X-FB-Debug: ZLzUJxF2s+6OjiLTmYKvaL8FDzFCMBjChm4vxXkPkBC63MewJLHthJSYIKPQKzGpr3ER9cWWfMpxec7UVN/k0Q==, Date: Tue, 19 Jan 2016 09:31:20 GMT, X-Cache-Ts: 1453195880, Connection: keep-alive, Content-Length: 159, null, null]
세션키 정책 {
질문: 세션키를 사용하는 이유는? => 잦은 DB로딩을 줄이려는 목적
	.접속하면 세션키를 발급받아 서버와 클라가 갖고 있는다.
	.만약 접속이 끊어져서 재접을 할때는 세션키를 함께 보내 접속한다.
	.서버에선 세션키를 받아 

	재접을 하는 상황
	  .클라에서 네트워크 변경으로 잠시 끊어진경우
	  .클라에서 임의로 끊은 경우
	  .서버가 죽어 연결이 끊겨 다시 재접하는 경우
	  -클라에서 네트워크 변경으로 잠시 끊어진경우
		.서버에선 끊어진걸 모르므로 연결이 그대로 살아있다.
		.다시 재접하면 세션키가 일치하여 다시 계정을 받지 않는다.
	  -클라에서 임의로 끊었다 재접한 경우
		.서버에선 일단 계정데이터를 바로 없애지 않는다.
		.클라가 다시 들어오면 세션키가 일치하므로 로그인만 시켜주고 계정은 새로 받고 보내주지 않는다.
	  -서버가 죽었다 살아난경우
		.클라가 재접해 오면 세션키가 다르다.
		.DB에서 데이터를 새로 받아온다.
		.새 세션키를 발급받아 보내준다.

  .서버에선 모를 수 있으므로 커넥션이 살아있다.
  .클라에선 끊겼으므로 다시 재접을 시도한다.
  .중복로그인처리가 되어 기존연결은 해제하고 새 연결로 다시 생성한다.
  .새 DB데이터를 받는다.
서버가 죽었다 살아난경우
  .유저들의 정보를 저장하지 못하고 죽은상황
  .클라에선 끊겼으므로 재접을 시도.
  .그러나 데이타가 백섭되어 서버와 클라의 데이터가 다름
  .이때는 데이터를 다시 받아야 함.
  .정상저장시 세션키도 DB에 함게 저장.
  .
클라가 끊겼을때 일단 계정데이타를 바로 삭제 하지 않고 보관한다.
일정시간 이내에 접속을 하지 않을때 삭제.
클라에서 접속할때 세션키가 일치하면 DB에서 다시 로딩하지 않고 메모리상의 데이타를 사용한다.

}

개발서버 단계 {
	xuzhu자리에서 개발하는 서버
	192번 개발섭(개발자만 접속)
	외부공개용 개발 테스트섭(외부관계자 접속용)
	오픈베타(일반유저용)
	정식
}


페북로그인 플로우
"557055802"
"100000786878603"
"100000786878203"
"100000786878605"
"422888354515288"
"100004602252270"

"1917811051777352"
"100010463058461"
"100000686899365"
"100002882537209"
"100000274211603"
"1377662711"
"171018822936702"
"171019052936679"
"1379861695612685"
"664936773579417"
"494164730653236"
"278203089013244"		// thumbnail, album, normal만 있음.
"375691212504985"
"405424532872449"
"1489534137948675"
"2303430311544"
"10203589094112277"
"10206843052747901"
"10200388672078845"
"10153241046122776"
"304785792997554"
"10104882054605370"
1385798771667701 동하
01-19 19:15:23.114: D/xuzhu(24426): WebGetImage:facebook: Request profile img:http://graph.facebook.com/1489534137948675/picture?type=large

http://graph.facebook.com/1385798771667701/picture?type=normal

로딩속도 분석 결과
{
	map.png가 2.7초
	scene world의 2초
	기타등등 2.3초
	월드씬 총 로딩시간 약 7초
	.스레드 로딩을 도입해야함. 
	  .중요리소스부터 로딩을 하도록 하고
	  .로딩이 아직 안된 객체는 draw를 안하고 있어야 함.
	  .로딩할 객체들을 큐에다 밀어넣고 스레드에서 차례로 읽으면 progressbar도 표현할 수 있다.
	  .파일 하나 읽을때마다 0.1초정도의 sleep을 줘야 할듯.
	.map은 잘게 쪼갠후 화면에 보이는 영역부터 먼저 로딩하고 나머지 영역을 후순위로 로딩하게 해야한다.
	.spr이 일반적으로 로딩이 조금더 늦으므로 애니메이션이 없는것(스팟같은)들은 중심점 맞추기가 까다롭더라도 png로 해야한다.
	.png나 spr중 실제론 작게 쓰는 리소스를 찾아서 축소시켜서 다시 저장.
	.패치받지 않은 파일은 apk에 있으므로 여기 파일을 읽을땐 zip로딩을 풀어야해서 추가 로딩시간이 들어간다. map같이 용량큰건 미리 워킹에 카피시켜두는것도 괜찮을듯 하다.
	.폰트크기가 달라질때마다 로딩속도가 추가로 들어가므로 가급적 폰트크기를 통일해서 써야한다.
	  .cheat모드에서 화면 한켠에 현재 로딩된 폰트들의 폰트이름과 크기리스트를 볼수 있게 하면 좋을듯.
	.압축텍스쳐의 사용
	.모든 png의 565포맷사용으로용량 감소.
}


보석광산 중복매칭 정책
{
	C라는 유저가 현재 1번광산을 차지하고 있고 상대는 안정해진상태
	A유저와 B유저가 동시에 C를 매칭시킴
	A가 먼저공격함. 공격과 동시에 C는 락이 걸림
	B가 공격함. 락이 걸려있으므로 공격못함. 
	여기서 B가 C를 못건드리도록 할 방법이 현재는 없음
	매칭할때 idEnemy가0인 유저를 찾은 직후 idFinder를 idEnemy에 갱신시켜서 애초에 중복 매칭이 안되게 하는수밖에 없음. 이미 그렇게 해놨기를.
	따라서 중복매칭을 일단 고려 안함.
}

보석광산 침공 시뮬 {
.성처럼 접속할때 랜덤으로 침공당한것처럼 바꿔준다.
  .내가 먼저 점령했던 광산인 경우(매치상대가 없는경우)
	.전투력으로 적절한 유저(노랑색범위,더미유저)를 얻어온다. JewelMatch로(상대가 아직 안정해진 유저)
	.더미가 나를 침공한것처럼 해야하므로 ChangeOwnerJewelMine으로 그 더미가 현재소유인것으로 바꿔놓는다.
	.정상공격을한다.
	.if(이기면) {
	  .정상처리처럼 소유정보를 내껄로 바꾼다.
	} else {
	  .정상처리처럼 방어도 하락 정보를 보낸다.
	}
  .나와 매치된상태이며 내가 현재 점령한경우
	.접속할때 랜덤으로 침공당한 여부를 결정하고, 다시 랜덤으로 이기거나 지는상황을 만듬
	if( 방어에성공한경우 ) {
	  .방어도만 깎아서 더미쪽의 스팟정보를 갱신시킨다.
	} else {
	  // 뺏긴경우.
	  .일단 내 스팟에 정보를 더미걸로 변경시키고 더미에게도 ChangeOwner를 해준다.
	}
}
On접속()
{
	if( 광산이 현재 내껀가 ) {
		if( 로그아웃 한시간이 지났나 ) {
			if( 주사위30% ) {
				// 침공당함
				if( 주사위50% ) {
					// 이김(방어성공)
					.해당스팟의 방어도를 깎는다.
					if( 내꺼였으며 아직 매치상대가 없었던 경우 ) {
						.JewelMatch로 더미유저를 얻어온다.(비동기)
						.ChangeOwnerJewelMine으로 그 더미유저의 상대를 나로 지정시킨다.(깎인방어도로 전송)
					} else {
						// 매치상대가 있었던 경우
						.더미유저에게 방어도만 갱신시킨다.								
					}
				} else {
					// 뺏김
					if( 내꺼였으며 아직 매치상대가 없었던 경우 ) {
						.JewelMatch로 더미유저를 얻어온다.(비동기)
						.내광산의 정보를 뺏긴걸로 바꾼다.
						.레벨을증가시킨다.
						.내껄 뺏아간것이므로 광산의 로컬 보석은 소실시킨다.
						.ChangeOwnerJewelMine으로 그 더미유저가 현재 소유인것으로 바꾼다.
					} else {
						// 매치상대가 있었던 경우.
						.내광산의 정보를 뺏긴걸로 바꾼다.
						.레벨을증가시킨다.
						.내껄 뺏아간것이므로 광산의 로컬 보석은 소실시킨다.
						.ChangeOwnerJewelMine으로 그 더미유저가 현재 소유인것으로 바꾼다.
					}
				}
			}
		}
	}
}



카리브 제로버전 설명
*이전버전(CPR버전)과 비교해서 바뀐부분
  .육성시스템이 대폭 바뀌었음.
	.영웅 3종 훈련
		.이전에 육성을 위해서 요구하던 징표/메달/보옥 등의 전리품을 더이상 요구하지 않고
		 모든것은 금화와 자원으로 가치가 집중됨.
		.영웅의 레벨업/부대업/스킬업은 금화로 경험치를 줄 수 있음.
		.위 3종성장 훈련을 시작하면 이전과 마찬가지로 훈련시간이 필요하는데, 이 훈련시간도
		 금화만 많다면 즉시 완료를 할 수 있음. 금화와 캐시 두개다 가능
	.유닛의 특성트리
		.유닛의 특성트리 연구가 이전엔 계정에 바인딩 되었었는데 이제 영웅에 개별적으로 바인딩되어
		 영웅별로 다양한 트리로 키울수 있게 됨. 따라서 같은 탱커 영웅이라도 vs창병에 특화된 영웅을
		 키울수 있는가 하면 vs골렘전문으로 키울수도 있게된다는 뜻임. 전투에 골라데려가는 재미가 생길것으로 예상함
		 또한 여러종류의 영웅을 키워야하는 이유가 생기게 됨.
		.특성트리연구는 자원만을 필요로 함.
		.이젠엔 특성트리의 업그레이드를 위해서 계정+1업마다 특성포인트1씩을 받아서 그걸로 찍었었는데,
		 이젠 자원만 많다면 제한없이 연구가 가능. 심지어 자원이 엄청나게 많다는 가정하에 모든 트리의 갈래를
		 다 찍는것도 이론적으론 가능함. 하지만 실제로는 그렇게 자원을 모을수 없어서 사실상 불가능
		 부족한 자원은 캐시로 메꿀수 있으므로 현찰로 가능하기는 함.
		.특성포인트를 찍을때 비용은 해당 유닛의 특성포인트 합계에 따라 비례해서 올라감.
		 게다가 다른 갈래로 갈아타려면 잠금해제 비용(금화)이 추가로 들어가므로
		 어느쪽 갈래를 탈건지 신중하게 결정해야함.
	.영혼석 시스템과 영웅의 별점등급변경
		.이제 모든 영웅은 고유함을 가짐. 같은 영웅을 여러명을 가질 수 없음.
		.모든 영웅은 1성부터 시작하게 됨.
		.해당 영웅의 영혼석을 모아서 새 영웅을 소환하거나 2성,3성등으로 승급이 가능함
		.이제 모든영웅은 액티브스킬과 패시브스킬을 반드시 갖게됨
		.액티브스킬은 1성부터 사용할 수 있지만 패시브스킬은 3성도달시 활성화 됨
		.최대 5성까지 키울 수 있음.
		.이젠에 군단장 스킬이라고 불리던 패시브 스킬이 개인 패시브 스킬로 변경됨.
		 그러므로 군단장이 되지 않더라도 자기 패시브 스킬은 자기에게 적용됨.
		.군단장시스템은 여전히 존재함. 군단장으로 지정된 영웅은 자기 패시브의 능력이
		 아군 부대 전부에게 적용됨.
		.모든영웅은 각자 고유한 액티브 스킬을 갖게됨. 따라서 모든 영웅들은 좋고나쁨의 편차가 없고
		 어느곳/어떤상황에 사용할것인가에 따라 가치가 달라지게 됨.
		.가챠뽑기시 일반뽑기는 1성으로 소환되며 가끔 운이좋으면 2,3성으로도 소환됨.
		.캐시로 하는 고급뽑기는 최소3성으로 완성되어 받게됨. 따라서 플레이어는 3성부터~5성까지
		 키울수 있음.
		.가챠뽑기시 영웅본체가 아니라 영웅의 영혼석이 소환되는일도 있음. 이미 가진 영웅이 뽑혀나오면
		 대신 영혼석으로 지급되어 그 영웅의 승급육성에 사용함
		.영웅의 초상화 부족으로 재사용이 많았었는데 일단 가라로나마 모든 영웅은 초상화가 다름.
		.모든 영웅이 고유한 스킬을 갖게됨에따라 그에 맞춰 스킬 이펙트와 스킬아이콘도 자원재조합등을
		 활용하여 모두 고유하게 만듬.
		.영웅의 영혼석을 얻는경로는 일반적으로 11렙에 등장하는 <영웅의전장>이라는 이벤트스팟에서 획득
		.그 외에 퀘스트의 보상으로 받는경우도 있으며 캠페인스팟의 마지막 클리어보상으로 받을수도 있고
		 길드레이드에서 모은 길드코인으로 길드상점에서만 파는 영웅의 영혼석을 구입가능. 
		 또 10레벨에 등장하는 <야만족의 본거지>라는 또다른 이벤트 스팟에서 얻을 수 있는메달을
		 시장의 무기상인에게 가져가면 상점에서 파는 전용 영혼석을 구입할수 있음.
  .월드맵 시스템 변경점
	.구름 지역이 더 세분화되어 배치됨. 예전엔 한레벨당 구름하나씩 까는것이었는데. 이제 한레벨지역
		내에서도 2,3번에 나눠 까게 되어있음.
	.성 스팟이 대폭 늘어나 자원 수급의 발란스를 조정함.
	.스팟위에 작게 뜨는 난이도 아이콘의 색과 모양을 참조하여 그 스팟의 난이도를 가늠할수 있음
		.회색/초록/노랑/주황/빨강 5단계가 존재
		.노랑은 나와 전투력이 거의 비슷하거나 살짝 높은 상대임
		.주황은 노랑보다 더 높은 전투력을 가지며 이기기가 상당히 어려우나 전략과 컨트롤
		로 가끔 이길수도 있음
		.빨강은 이기기가 거의 불가능
		.초록은 어택땅만 해도 웬만하면 이김. 나보다 전투력이 살짝 낮은 상대
		.초록이하의 전투력은 모두 회색.
		.색난이도에 따라 전투후 얻게되는 자원루팅양도 변화가 있음. 따라서 높은등급을
		상대해야만 큰 자원을 먹을 수 있음.
		.월드맵에 타유저의 성스팟이 스폰될때 그 지역의 지역레벨에 맞춰 스폰이 됨.
		.예를들어 나와 동렙지역을 오픈해서 매칭이 되면 노랑색이나 주황색이 매칭됨.
		.10레벨 이후부터는 구름지역 제거에 레벨제한이 걸려있지 않으므로 금화만 있다면
		계속 오픈이 가능함. 하지만 나보다 높은레벨의 지역은 대부분 빨강으로 매칭되므로
		이이기는 힘듬.
		.위 방식으로인해 내가 강해져서 더 강한상대와 붙고싶다고 하면 더 높은 지역을 오픈
		해서 싸우면 됨.
		.각 스팟에 별점시스템이 추가됨.
		.현재는 npc스팟과 성스팟만 적용됨.
		.스팟에서 전투를 끝내면 성과에 따라 1~3별을 받게 됨.
		.이별은 맵상에도 표시되며 계정에 누적됨.
		.별모으기 퀘스트가 같이 생기게 되는데 해당 별개수를 모아 퀘스트를 완수하면
		많은 보상이 기다리고있음. 
		.별퀘를 클리어하면 그만큼의 별을 차감하고 다시 다음단계의 별퀘를 받게됨.
		물론 보상은 점점 좋아짐.
		.3별로 클리어하면 스팟에 별표시가 사라짐.
		.이벤트성 스팟인 징표의 전장은 이제 각각 요일마다 다른 자원을 보상으로 지급함
.그 외
  .현재 경제/전투/성장 발란스를 함께 맞추며 작업중임. 플레이 후 발란스에 대한 조언바람.
  .동운씨가 바꿔줄 UI중 일부가 아직 적용이 안되고 가라UI로 적용이 되어있는것을 감안해주기바람
  .20렙이후로 구름과 스팟이 찍혀있지 않음. 따라서 20렙까지 플레이가 가능하다는 뜻. 20렙까지 플레이를
   통해서 큰 문제가 없다면 이후 지역을 모두 배치할것임.
  .영웅이 모두 고유하며 고유한 스킬을 가진다고 했는데 아직 모두가 그렇게 적용되지 않음
	.탱커영웅들은 초상화만 고유하게 입력해둔상태고 원거리영웅들은 액티브스킬들이 모두 고유한것으로
	 입력되어있는 상태임
  .npc/성스팟을 제외한 다른 스팟들은 아직 정상작동을 안할수도 있음. 빠른시일내에 수정하겠음
  .비주얼 전체적으로 일단 구현을 위해서 내가 가라로 만들어서 넣은 UI들이 상당히 많음. 나중에 한꺼번에
   동운씨가 검수해줬으면 함.
  .튜토리얼이 현재 빠진 상태임. 앞부분 플레이 흐름이 바뀐게 좀 있어서 임시로 빼놓음. 조만간 다시 넣겠음
  .튜토리얼이 빠짐으로써 튜토리얼로 얻는 경험치가 없는 바람에 극초반 플레이시 진행하는데 시간이 많이 걸린다거나 하는일이 생김. 
	특히 스팟들이 리스폰이 안되서 기다리는일이 생기는데 그냥 캐시로 소환해서 플레이바람.
  .접속하면 등장하는 팝업 팁이 현재 시스템과 설명이 맞지 않음. 이것도 빠른시일내에 수정해놓겠음
  .전투밸런스가 약간 수정되었는데
	.각부대의 병과간 상성에서 우세한쪽이 25%의 추가데미지가 들어감. 또한 우세한 상대로는 받는 데미지도 25%덜받음
	.탱커계열부대(창병/미노타우르스/골렘)는 스피드계열부대(기사/라이칸/타천사)에게 우세함
	.스피드계열부대는 원거리부대계열에게 우세함
	.원거리부대는 탱커부대를 상대로 우세함
	.또한 각 유닛은 대/중/소의 크기속성이 있는데 이 역시 우세한 상대로 +25%의 추가데미지와 -25%의 피해감소 효과를 받음
	.대형은 중형에게 우세
	.중형은 소형에게 우세
	.소형은 대형에게 우세함
	.소형: 창병/궁수/기사
	.중형: 미노타우르스/사이클롭스/라이칸
	.대형: 골렘/앤트/타천사
  .맵에 등장하는 모든 성스팟은 서비스시 실제 플레이하는 다른 유저가 매칭됨. 현재는 유저가 
   있는것처럼 시뮬레이션 하기 위해 더미계정을 약 만개정도 만들어 둠. 이름은 모두 "TEST_USER"







	  

  .유닛의 잠금해제
	.유닛은 최초 창병과 궁수만 제공됨.
	.계정렙3이 되면 기사를 잠금해제할 수 있게 됨.
	.계정렙9렙이 되면 나머지 6종의 유닛중 하나를 오픈할수 있게됨.
	.그이후부터 약 계정렙2,3마다 한번씩 오픈기회가 돌아옴.
  .
  .밸런스
	.유닛밸런스

	







Lv11, 6120->5840
Lv2
g:1800
w:3140
i:3744
Lv3
g:1800
w:4963
i:6231
Lv4
g:500
w:7999
i:8231
Lv5
g:6708
w:9791
i:10231
Lv6
g:5608
w:11903
i:10231
Lv7
g:4208
w:14831
i:10231
j:1268
m:1232
Lv7징표전장이전
g:2508
w:19060
i:14164
j:2324
m:1232
Lv7전장이후
g:75508
w:19060
i:14164
j:2324
m:1232





퀘스트만 빼고 정살플레이 테스트하여 플레이가 가능한지 체크
전투시 컨트롤 튜토리얼 넣어야함

맵 오브젝트
{
	.월드맵상을 어떤 계산식이나 경로에 의해 움직인다.
	.구름과 스팟의 사이 레이어에 놓이게 한다.
	.옵션으로 그림자를 지닌다(새)
	.생성되는 지점이 지정되어 있다.
	.사라지는 규칙이나 위치가 있다.
	새 {
		.스크린상의 아래쪽에서 생성되어 위쪽으로 사라진다.
		.스크롤시 자연스럽기 위해 화면 1.5배 넓은영역으로 생성한다.
	}
}



*책제공 씬

.아카데미 지역을 깐다.
.아카데미의 잠금이 해제된다.
.find.academy컷씬이 실행된다.
.막사로 안내한다
.academy컷씬이 실행된다.
예외1: 
.잠금이 해제되고 컷씬이 실행되고있는중에 죽었다.
.잠금해제 이벤트는 다시 오지 않기때문에 find.academy튜토는 영원히 볼수없다.
.월드맵씬에 진입할때 한번더 검사해야한다.
.월드맵씬에 진입하면 모든퀘스트를 순회하며 조건이 충족이 되었는데 실행안된 컷씬이 있는지 검사한다.
예외2:
.find.academy컷씬이 끝난후 죽었다.
.막사씬에 진입했을때 prev_seq로인해 academy컷씬이 실행된다.
다시
.아카데미지역을 깐다.
.보옥제공퀘를 받는다.
.보옥제공퀘의 확인을 하면 find.academy컷씬이 실행된다.
.
#모든 튜토리얼은 퀘스트확인으로부터 시작되어야 한다.



알림종류
{
	.훈련완료(연구완료 포함)
	.공격기록
	.방어기록
	.
}


5레벨 부대슬롯이 늘어나면 부대추가 퀘스트
무역상 초반엔 가지않게 하든지 그렇게.


randomize();
s_x=x;
s_y=y;
lifetime=irandom_range(120,240);	//
target_x=x+irandom_range(-20,20);
movespeed=random_range(0.1,1.4);

blendmode=0;
b_mode=bm_normal;

image_xscale=random_range(1,3);
image_yscale=image_xscale;
image_alpha=0;

move_towards_point(target_x,0,movespeed);
alarm[0]=1;
alarm[5]=10;

alarm[6]=floor(lifetime/4)

알람0 코드
if image_alpha<0.5{
 image_alpha+=0.05
 alarm[0]=2
}
else{
 alarm[1]=lifetime
}

알람1 코드
if image_alpha>0{
 image_alpha-=0.005
 alarm[1]=2
}
else{
 instance_destroy();
}
알람5 코드...
target_x=x+irandom_range(-10,40);
move_towards_point(target_x,0,movespeed);
alarm[5]=10
알람6 코드
 instance_create(s_x,s_y,object0);

alpha
	.0에서 시작. 0.5까지 증가. 2프레임단위로 0.05씩 증가.(0.33초간)
	.0.5에서 2~4초 지속.
	.0.5에서 다시 0까지 감소. 2프레임단위로 0.005씩 감소.(3.3초간)
x좌표
	.최초X에서 +-20 으로 이동
	.10프레임뒤에 다시 목표X지점을 설정



1-1 스팟터치
	 .성: 
		  .내소유가 됐을때:
			   .빠지는 것
					.'자원보상', '획득아이템'
			   .추가되는 것
								 
	 

파티클 시스템
{
	.전투필드에서 y소트를 해야하므로 오브젝트별로 파티클 이미터가 있어야 한다.
	.draw도 오브젝트별로 따로 draw해야한다.
		.만약 depth버퍼를 쓴다면 하나의 파티클 매니저가 한꺼번에 전부 그려도 된다.
	.일단 y소트 무시하고 그냥 하는걸로?
	.오브젝트별로 이미터객체n개 보유
		.이미터객체는 파티클을 생성하여 파티클매니저에 등록.
		.파티클매니저가 등록된 파티클들을 한꺼번에 드로우.
	.이미터객체는 트리구조로 하여 여러 이미터를 묶을수 있게 한다.
	이미터
	{
		파라메터
			.방출위치(이미터위치)
			.방출 주기(선형,사인파형,가속형,감속형 등 각종보간함수)
			.한번에뿜어내는 입자개수(각종 보간함수)
			.이미터 방출위치변형(이동)함수(원형,선형,스플라인형등)
			입자파라메터
				.텍스쳐
				.크기
				.방출방향
				.방출속도
				.생존시간
				.
		.이미터 하나는 무조건 한가지 파라메터만 가지는 방식
		{
			.
		}

		.이미터 하나에 랜덤성 범위파라메터를 주는 방식
		.이미터를 상속받아 
	}
	종류
	{
		.분수형태
			.파티클의 개별 애니메이션 없음
			.잔상정도 처리는 가능.
			.생존시간,크기,알파,방향,속도,중력처리,지면충돌처리
		.화염
			.파티클 개별 애니메이션 있음
				.sprObj:간편, 무거움
				.png낱개:각 애니프레임의 크기 같음.
				.아틀라스:중심점에 대한 별도 데이타 필요.
						.중심점과 애니메이션만되는 가벼운 SprObj필요.
			.생존시간,크기,알파,방향,속도
	}
}




서버점검 공지
 * 커다란 창과 종료 버튼
 * 로그인서버에서 "점검중" 플래그를 작동시킨다.
 * 플레이어가 접속해 왔을때 점검중이면 미리 준비해둔 메시지(파일 혹은 직접입력)를 보낸다.
클라업데이트 공지
 * Resource폴더에 미리 준비해둔 텍스트에 업데이트 내용을 기록하고
 * 새 업데이트를 최초 실행시키면 그 내용을 공지창으로 띄워준다.
 * 같은내용을 메일로도 전송한다. 캐쉬50개와 함게

*스팟에 신호를 주면 해당 스팟윈도우가 n초간 깜빡깜빡.
	.특정 스팟 클리어/정찰/방문
	.특정 스팟들 클리어/정찰
	.특정 타입의 스팟들에서 루팅아이템 얻기
*신호를 주면 해당좌표로 n초간 맵 이동
*특정 지역의 중간위치
*특정 코드스팟의 중간위치
.해당 좌표에 화살표가 n초간 통통 튀기
	.레벨,지역열기
	.자원얻기
	.
레벨달성: 화살표
지역오픈: 맵이동




json방식 패킷
{
	클라::RecvPacket( p )
	{
		DWORD idAcc = p.GetDWORD("id_account");
		int num = p.Getint("num");
		_tstring str = p.GetString("name");

	}
	서버::SendPacket()
	{
		p["id_account"] = idAcc;
		p["num"] = num;
		p["name"] = name;
		p["name2"] = name2;
	}
}



타이머 저장
{
	서버
	{
		xSec m_secStart;	// 시작한 초
		Serialize()
		{
			secPass = XTimer2::sGetTime() - secStart;
			ar << secPass;		// 지나간 시간만을 저장한다.
		}
		Deserialize()
		{
			ar >> secPass;
			m_secStart = XTimer2::sGetTime() - secPass;	// 현재시간에서 지나간시간을 빼서 시작시간으로 쓴다.
		}
		RecvTimeOverCheck()
		{
			secPass = XTimer2::sGetTime() - m_secStart;
			if( secPass > secTotal )
			{
				// time over;
				SendAcceptTimeOver();	// 클라에 확인시켜줌.
			}

		}
	}
	클라
	{
		Deserialize()
		{
			ar >> secPass;
			m_secStart = XTimer2::sGetTime() - secPass;	// 현재시간에서 지나간시간을 빼서 시작시간으로 쓴다.
		}
		Process()
		{
			secPass = XTimer2::sGetTime() - m_secStart;
			if( secPass > secTotal )
			{
				// time over
				SendTimeOverCheck();	// 서버로 문의
			}
		}
	}
}




8레벨에서 언제 퀘스트가 갑자기 늘어나는지 확인한다.
너무 늘어나면 백병전 메달 얻는퀘를 징표퀘로 바꾸거나 앞에 ,npc잡는퀘를 삽입한다.

maxTry==0 : 1회 도전가능
maxTry==1 : 1회 도전가능
maxTry==2 : 2회 도전가능
maxTry==5 : 5회 도전가능








*책먹일때마다 목재/철 필요한 타입
{
	.현재의 골드대신 자원으로 교체된다.
	.경험치가 다 쌓이면 레벨업 버튼이 나오고 누르면 일정시간 후에 훈련이 완료되고 렙업이 된다.
	.렙업시에는 자원이 필요하지 않다.
	.만약 자원이 많이 쌓여있다. 난 영웅업글을 해야하지만 훈련소가 다차서 못하고 있다.
		.현재 훈련소 훈련의 남은시간을 캐쉬로 보상하고 즉시 끝낸다.
		.이방식은 업글시 자원을 쓰지않으므로 쌓여있는 자원에 대한 불안감을 주지 못함.
	.자원이 꽤 쌓여있다. 하지만 업글에 필요한 자원이 조금 모자라다.
		.난 뺏기는게 두렵다. 

}
*책먹일때는 그냥 하고 렙업할때 자원이 필요하느 타입
{
	.책먹일때는 자원이 필요하지 않다.
	.경험치가 다 차면 레벨업 버튼이 나오고 필요한 자원양이 나온다.
	.현재 훈련소가 비어있다면 자원이 소모되고 즉시 훈련이 시작된다.
	.만약 자원이 많이 쌓여있다. 난 영웅업글할 자원은 모았지만 훈련소가 다차서 못하고 있다.
		.현재 훈련소 훈련의 남은시간을 캐쉬로 보상하고 즉시 끝낸다.
	.자원이 꽤 쌓여있다. 하지만 업글에 필요한 자원이 조금 모자라다.
		.난 뺏기는게 두렵다. 모자라는 자원을 캐쉬로 메꾸고 훈련을 시작한다.
}


캐쉬스팟
{
	*지정된 장소에 스팟을 미리 배치시켜둔다.
		-랜덤일 경우에 기존스팟과 겹치는등의 부작용이 생길 수 있음.
	*생성이나 먹고난후 일정 대기시간이 지나면 다시 리젠된다.
	*캐쉬는 1~5개 정도가 리젠된다.
}


만드레이크 UI
{
	#스팟이 상대것일때
		.내가 먹을수 있는 보상양(쌓여있는양의 50%)을 알수 있어야 한다.
	#스팟이 내것일때
		.현재까지 쌓은 승수가 표시되어야 한다.
		.현재까지 쌓인 보상을 알수 있어야 한다.
		.현재까지 쌓은 보상을 회수하고 리셋시킬 방법이 있어야 한다.(회수...) <- 버튼 이름. 혹은 ...만
		.생산량 증가 버프 버튼.
		.방어전을 다시 볼수 있는 버튼까지 있으면 좋다.

	.
}

리플레이
{
	변화요소
	. 사용자의 입력
	사전 필요한 데이터(공통)
		.양측 군단배치
			.각 영웅의 레벨
			.각 영웅의 스킬레벨
			.각 영웅의 장비
			.각 부대의 레벨
		.각 프로퍼티의 버전값.(버전값이 달라지면 리플레이 데이터는 삭제해야한다)
			.초반 서비스에는 값이 자주 바뀔 우려가 있으므로 리플레이 기능을 잠시 막아두는것도 한방법
		.양측 특성트리 데이터
		.
	디버깅 전략
		.매프레임 모든 유닛들의 주요데이터(좌표,공격플래그,체력 등을 저장해둔다)
		.이 데이터를 확장하여 보안에 사용할수도 있다.
}


원형UI
{
	.성스팟: 공격/정찰/수거/(리젠/상대바꾸기)
	.보석광산: 공격/정찰/수거/상대바꾸기
	.유황스팟: 공격/정찰(리젠)
	.만드레이크: 공격/정찰/상대바꾸기
	.NPC: 공격/정찰/(리젠)
	.요일스팟: 공격/정찰
	.스페셜스팟: 공격/정찰
	.
}

정우
{
	.캐쉬 사용 및 기능-3일
	.정찰 창-0.5
	.패치 클라이언트-3일
	.아이템/자원/영웅 관련 퀘스트 UI-1
	.공격침략 로그창-2
	.튜토리얼-7
	.레이드-2
	.무료 캐쉬 시스템-2
	.매칭 알고리즘-2
	.리플레이-3
	.유황스팟 오프라인동안 뺏은거 표시.
}
정완
{
	.상점에 월정액 캐쉬 추가
	.공지 및 시스템 메시지
	.우편함 및 운영자 공지 및 아이템 보내기
	.캠페인 시스템 UI
}
재범
{
	.닉네임 등록
	.계정 등록
	.전투전 배치 씬
	.연방기능 구현

}







용맹포인트 획득
{
	.승패에 관계없이 적을 많이 죽이면 많이 획득한다.
	.소형병사 1당 1점. 중형5점. 대형20점
}


소환물의 조건
{
	.독자적인 squad처럼 움직여야 한다.
	.추적과 공격이 가능해야 한다.
	.독자적인 공격력과 체력을 가져야 한다.
	.적이 타겟을 잡을때 잡혀야 한다.
	.전멸조건에 포함되어야 한다.
	.
}

사이클롭스
{
	.텔레포트: 근접공격을 받으면 일정확률로 뒤로 순간이동한다.
	.확산: 열선의 피해범위 증가
}
골렘
{
	#자폭특성이 소형에게 특히 유리하므로 버티기 궁극특성은 중.대형에게 유리하도록 한다.
	.절대방어: 죽기직전 피해감소가 대폭증가하며 움직이지 않는다.
	.재건축: 죽으면 일정확률로 체력이 50%회복된다.
	.탄성피부: 골렘을 공격한자는 일정확률로 기절한다.
}

엔트
{
	.무성한나무: 중형유닛까지 가려 회피율을 증가시킨다.
	.
}

리더패시브 구현방식
{
	* 리더의 패시브를 자신의 것이었던것처럼 자신에게 사용하는 방법
	{
		.자신의 것이었던것처럼 자신에게 쓰는것이기 때문에 기존시스템과 잘 섞인다.
		.리더가 죽으면 해제되어야 하므로 항상 리더의 사망여부를 체크해야 한다.
		.선별적으로 걸려야 하는 경우는 시전대상이 자신이어도 시전대상필터가 추가로 필요하다.
		.개념상 자신이 쓴게 아니므로 시전자의 개념에 충돌이 있을수 있다.
	}
	* 리더가 아군들에게 걸어주는 방식
	{
		.전투시작전 리더의 패시브에서 발동형태로 아군들에게 걸어준다.
		.개념적으로 생각하는것과 일치하는 방식.
		.모든 스킬이 발동스킬 형태여야 한다는 번거로운점.
		.리더가 죽으면 해제되어야 하므로 리더의 사망을 체크하는것은 동일.
		.선별적으로 걸려야 하는 경우는 발동대상의 필터로 걸러낼수 있다.
		.시전자와 발동자가 명확히 구분되므로 개념에 대한 혼동이 없다.
		.
	}
}


	다른 XWndView쓴것들 모두 새 방식으로 교체

정찰퀘인데 그 부대를 죽여버렸을때.
 .정찰퀘부대는 공격이 안되게 해야 한다.
when이 두개인경우 스팟등장문제
구름아래 스팟이 클릭되는 문제(주로 이벤트 스팟)
아이템/영웅 퀘 아이콘 표시
유황수송대 이름 레이블이 제대로 안찍히는 문제.

특성트리
{
	.포인트를 n개 받으면 각 유닛당 1포인트씩만 개발할 수 있다.
	.올리기 원하는 특성을 선택한 후 +를 누르면 연구시간과 자원이 팝업으로 표시되고 연구가 시작된다. 
	.연구에는 일정시간이 소요된다.
	.특성을 선택하면 현재 선택된 특성아이콘 주위에 빛나는 애니메이션이 일어난다.
	.연구중에는 해당 유닛의 다른 특성은 찍을 수 없다.
	.연구가 시작되면 +버튼은 사라지고 그자리에 연구 프로그레스바가 생긴다.
	.다시 이화면으로 들어왔을때 현재 연구중인 아이콘과 프로그레스바가 보여진다.
}
	




XWnd 개선 전략
{
	*XWndView( XLayout* )
		.모든 차일드의 좌상귀 좌표를 검색해서 최대값을 XWndView의 pos으로 사용한다.
		.모든 차일드의 위치와 크기를 고려해서 XWndView의 크기로 정한다.
		.XWndView는 화면 어느 위치에나 배치될수 있다.

	*XWndDialog / 혹은 XWndPopup
		.화면가운데 위치하는 팝업류창에 사용한다.
}


캠페인시스템
{	
	*캠페인 하나의 식별자
		.name: 캠페인 이름
		*stage(복수)
			.num_win: 클리어해야 할 횟수
			.num_try: 도전횟수(시간이 지남에따라 서서히 회복됨)
			.elite: 0=일반, 1=정예
			.limit_level: 스테이지진입 레벨제한
			.point: 소모 용맹포인트
			*legion
				.num_squad: 부대수
				.level: 군단의레벨(절대값)
				.boss: 영웅이름(squad를 수동으로 지정했을 경우. 자동군단이라면 3열 중앙이 군단장이 된다)
				*squad(복수) // 수동으로 지정해야할 부대가 있다면...
					.pos: 부대위치. 앞열위쪽부터 1,2,3,4,5,6,7,8,9
					.hero: 영웅이름 or random
					.unit: 유닛이름 or random
					.level_squad: 부대레벨
					.level_skill: 스킬레벨
					.level_hero: 영웅레벨
					// 생략한 파라메터는 군단랜덤데이타를 기본으로 상속받는다.
	*작업순서
		.xml구조 설계
		.xml 로더
		.캠페인 스팟구현
		.임시 UI제작
		.캠페인을 통하여 전투
		.캠페인 클리어 UI처리
		.부대생성 알고리즘
		.
}

용맹포인트의 사용
{
	*용맹포인트에는 레벨별로 최대값이 있다.
	*전레벨에서 용맹포인트를 모아서 다음레벨에서 특성트리를 찍는다.
	*용맹포인트가 풀로 차있을때 특성트리를 찍으면 30%가량 소모된다.
	*남은 포인트로 캠페인을 하거나 보석으로 교환한다.
	*캠페인이 적은레벨대에서는 포인트가 많이 남지만 캠페인이 많은 레벨대는 포인트가 모자라 특성을 찍을수 없게 된다.
	*애초에 용맹포인트를 도입한것은 특성연구를 찍고싶다는 욕구를 목표로 삼게 하기 위함.
	*특성트리에 써야할 포인트를 캠페인에 소모한다면 캠페인하기 싫지 않을까?
	*그렇다면 캠페인은 뭘 소모하게 해서 제한을 시킬건가.
	*행동력?
		.모든전투는 행동력을 소모한다.
		.스팟이라는 시스템이 있는이상 스팟은 주기적으로 리스폰되어야 한다.
		.npc스팟이나 유황스팟의 경우 평소에는 스팟이 없으므로 대신 뭔가가 그자리를 차지하고 있어야 강제리스폰을 시킬수 있다.
		.유저스팟 공격이냐 캠페인이냐 기회비용을 따지게 될수 있다.
		.돈벌기 위해서 유저스팟만 공격할테고 다음지역을 열기위해 캠페인을 해야한다면 그건 억지로 싫은 선택을 강요하게 되는거라 별로.
		.캠페인은 캠페인을 깨는 그자체가 즐거움이고 목표가 되어야 한다.
		.그렇다면 캠페인을 연속적으로 순식간에 깨지못하게 할 다른방법은?
		.재도전시간을 두는것은 좀 억지
		.캠페인 포인트를 따로 두는방법. => 포인트종류가 너무 많아지는 단점.
		.캠페인 하나를 깨고나면 다음 캠페인을 깨는건 조금씩 더 시간이 걸려야 한다.
		.딴데서 전투하고 놀다가 다시 오게 하는게 가장 낫긴 하다.
		.그렇다면 역시 용맹포인트가 제일 무난?
		.특성트리에 용맹포인트를 쓰지 않고 자원만으로 하게 한다면?
		.캠페인을 깨기위한 용맹포인트 노가다가 된다. 캠페인이 보상이 좋다면 충분히 동기부여 된다.
		.결정.
}

퀘템 드랍
{
	.퀘템은 기존 스팟에서도 퀘이벤트용 스팟에서도 드랍될 수 있다.
	.그러므로 propWorld스팟정보에 기록하면 곤란하다.
	.퀘스트 자체에 어떤스팟에서 드랍이 되어야 하는지를 기술하고 드랍처리할때 퀘스트의 드랍정보를 참조하도록 한다.
}

스팟코드 격파퀘의 경우
{
	.퀘를 받음과 동시에 해당 스팟들이 나타나야 한다.
	.해당스팟들은 "code.defender"같은 공통 식별자가 있다.
	.propWorld에 해당 스팟들을 미리 심어둔다.
	.스팟 등장/해제조건을 "quest.001"을 받을때/완료할때로 지정한다.
	.서버에서 퀘를 받는 이벤트에서 생성해야할 스팟이 있는지 검사한다.
	.생성한 스팟을 World객체에 포함시킨다.
	.퀘완료 이벤트에서 삭제해야할 스팟이 있는지 검사한다.
	.해당 스팟들을 삭제한다.
}
특정스팟 격파퀘
{
	.위와 같다 다만 code대신 식별자를 입력한다.
}


On레벨업()
{
	DoOccurQuest( LEVEL_UP, 레벨 );
{
On접속()
{
	DoOccurQuest( LEVEL_UP, 레벨 );
}
On스팟퇴치()
{
	QuestMng->DispatchEvent( 스팟퇴치, 스팟아이디 );
}

DoOccurQuest()
{
}

퀘스트 예제
{
quest001.xml
{
	퀘스트
	{
		식별자
		{
			제목id
			설명id
			언제(퀘 등장조건)
			{
				레벨:
			}
			어디서(퀘 수행장소)
			{
				스팟: <스팟 식별자>
				스팟류: 성스팟
				지역: 식별자
			}
			무엇을(퀘 완료조건)
			{
				스팟퇴치: <스팟 식별자> - 복수가능
				스팟정찰: <스팟 식별자> - 복수가능
				스팟방문: <스팟 식별자> - 복수가능
				아이템획득: <아이템 식별자> - 복수가능
			}

		}
	}
}
On퀘받음
{
	if( 퀘.무엇을 == 스팟퇴치 || 정찰 || 방문 )
	{
		if( 퀘.어디서 == 특정스팟 )
		{
			if( 없는스팟인가(퀘.어디서.스팟식별자) )		// 특정스팟을 깨야하는경우
				스팟생성( 퀘.어디서.스팟식별자 );
		} else
		if( 퀘.어디서 == 특정스팟류 )
		{
			
		}
	}
}

On스팟생성
{
	
}

On스팟클리어( 스팟정보, 부대정보 )
{
	이벤트정보.Add(스팟정보)
	이벤트정보.Add(부대정보)
	퀘스트매니저.이벤트처리( 스팟퇴치_이벤트, 이벤트정보 );
}

On스팟정찰( 스팟정보 )
{
	퀘스트매니저.이벤트처리( 스팟정찰_이벤트, 스팟정보.아이디, 
										스팟정보.종류, 
										스팟정보.지역,
										 );
}

On아이템획득( 아이템 )
{
	X이벤트정보 이벤트정보( .Add(획득아이템)
	퀘스트매니저.이벤트처리( 아이템획득_이벤트, 이벤트정보 );
}

이벤트정보::비교( 퀘, 조건코드, 파라메터 )
{
	if( 조건코드 == 스팟퇴치 )		// 모든 조건코드는 중복되지 않아야 한다.
		if( 파라메터 == 스팟정보.아이디 )
			return true;
	if( 조건코드 == 특정아이템획득 )	// 무엇을
		if( 파라메터 == 획득아이템아이디 )
			if( m_pAccount->몇개인가( 조건코드, 파라메터 ) >= 퀘.얼마나.파라메터 )
				return true;
	if( 조건코드 == 자원획득 )
		if( m_pAccount->몇개인가( 조건코드, 파라메터 ) >= 퀘.얼마나.파라메터 )
			return true;
	if( 조건코드 == 특정스팟에서 )		// 어디서
		if( 파라메터 == 스팟정보.아이디 )
			return true;
	if( 조건코드 == 한정된부대수로 )	// 어떻게
		if( 부대정보.부대수 <= 파라메터 )
			return true;
		
}

퀘스트매니저::이벤트처리( 이벤트종류, 이벤트정보 )
{
	루프( 퀘 = 보유퀘 )
	{
		b퀘완료 = true;
		루프( 퀘조건 = 퀘.조건리스트 )
		{
			if( 퀘조건.무엇을 == 이벤트종류 )
				if( 이벤트정보.비교( 퀘, 퀘조건.무엇을, 퀘조건.무엇을.파라메터 ) )
					if( 이벤트정보.비교( 퀘, 퀘조건.어디서, 퀘조건.어디서.파라메터 ) )
						if( 이벤트정보.비교( 퀘, 퀘.어떻게, 퀘.어떻게파라메터리스트 )
							if( 이벤트정보.비교( 퀘, 퀘.얼마나, 퀘.얼마나파라메터리스트 )
								if( 퀘.얼마나 > 0 && 
								if( 퀘조건.수행횟수증가(이벤트정보.횟수) )
									퀘조건.완료();
		}
		if( 퀘.모든조건완료?() == true )
			퀘.완료();
	}
}

퀘조건::수행횟수증가( 증가량 )
{
	m_num += 증가량
	if( m_num >= m_최대량 )
		return true;
}

아이템 A,B,C를 구해오는 퀘스트
	.만약 A,B,C를 다 구해서 퀘 완료상태가 된후 A를 버리거나 뽀갠다면?


On자원획득( 자원코드, 수량 )
{
	이벤트정보.횟수 = 수량
	퀘스트매니저.이벤트처리( 자원획득_이벤트, 이벤트정보 )
}

On퀘스트완료및보상요청( 퀘 )
{
	if( 퀘.모든조건완료?() )
		지급( 퀘.보상 );
}

퀘_횟수퀘::모든조건완료?()
{
	b퀘완료 = TRUE;
	루프( 조건 = 완료조건리스트 )
	{
		if( 조건.완료 == false )
			b퀘완료 = false;
			break;
	}
	return b퀘완료;
}

퀘_획득(보유)퀘::모든조건완료?()
{
	루프( 조건 = 조건리스트 )
	{
		조건.현재수량 = GetpDelegate()->몇개인가?( 조건.아이디 );
		if( 조건.현재수량 < 조건.총개수 )
			return false;
	}
}

XAccount::몇개인가?( 무엇을, 아이디 )
{
	if( 무엇을 == 아이템획득 )
	{
		return this.GetNumItem( 조건.아이디 )
	} else
	if( 무엇을 == 자원획득 )
	{
		return this.Get자원(아이디)
	}
	return true;
}




퀘_횟수퀘::얼마나조건처리( 이벤트정보 )	// 혹은 개수
{
	m_횟수 += 이벤트정보.얼마나;
	if( m_횟수 == 지정된횟수 )
		return true;
	return false;
}

}

.퀘조건 5이상
	.현재레벨1~4 => 생성안함.
	.현재레벨5 => 생성
	.현재레벨6 => 생성안함.


원래 큰 이미지를 작게 줄여서 UI로 쓰고쓰고싶다. 그 UI는 확대축소가 되어야 한다.
{
	*로딩때부터 텍스쳐 크기를 지정해서 로딩하는 방법
		.버텍스 버퍼 자체를 줄여버린다.
		{
			// test.png는 128x128
			pSurface = Load("test.png", 64,64);		// 읽을때부터 64짜리 버텍스버퍼로 읽는다.
		}
		.정적인 방법
	*서피스에 로컬 매트릭스를 갖고 있는다.
	{
		pSurface = Load();
		pSurface->SetLocalScale();
		pSurface->SetLocalPos();	// 텍스쳐 자체가 좌상귀가 원점이 아닌경우. 이럴경우 UI로 사용시 좌상귀 좌표로 쓰기가 힘들다.
		// 동적인 방법

	}
}

특성들의 특성
{
	.문제점: 특성효과를 유닛 개별로 적용할것인가. 부대단위로 적용할것인가.
	예1) 근접공격을 일정확률로 회피 => 유닛 개별동작
	예2) 공격력증가 => 부대단위 동작
		* 유닛 개별단위로 적용할때 문제점
			.보통 일정확률이 있는 경우이며 개별적으로 확률에 의거해 적중하므로 "회피"메시지를 유닛개별로 띄워줘야 한다.
			.만약 메시지를 띄워주지 않는다면 문제는 없다. 다만 회피시 피드백이 없어서 발동을 하고 있는건지 알수가 없다.
			.전투통계에서 부대별 회피량을 보여준다면 해결.
			.회피율이 50%씩 되는것도 아니라서 의외로 회피메시지가 별로 안나올수도...
		* 부대단위로 적용할때 문제점
			.유닛 개별간의 이벤트에 대처하지 못한다.(영웅의 마법피격이면 모를까, 부대단위 회피가 있을순 없다)
			.확률이 없는형태로 변경해야 한다. 회피=>데미지감소
		= 부대단위로 적용하되 확률방식은 피해야 한다.
	*타입
		.항상
		.공격시 발동
		.피격시 발동
		.전투시작시 발동
		.새 타겟선정시 발동(쿨타임 존재)
		.죽을때 발동
		.적부대를 전멸시킬때 발동
		.협공시 발동
		.
}

특성작업 목록
{
	.특성트리 포인트 찍을수 있는 UI
	.특성트리 트리를 따라 찍을수 있도록
	.특성트리 찍을때 서버 저장.
	.새 유닛 등장 레벨 확인과 특성트리완성 플로우.
	#유닛 개별 이동속도 둔화시 부대전체 이동력 감소 구현
	#치명타 구현
	#회피 구현
	.은신 구현
	.종족
	.하드코딩 체계적으로 할수 있도록 시스템 설계
	.특성아이콘 제작
	.특성트리 제작(규홍)
}







더미 제네레이터 개발전략
{
	#목표: 원활한 게임플레이를 위한 다양한 조건의 가상계정을 DB에 준비하는것이 목적.
	#조건:
	.기본 데이타를 가지고 있는 계정 생성
		.기본데이타란?
	.랜덤 레벨(1~20)
	.레벨에 따른 랜덤 영웅 보유(레벨당1 + random(3))
	.레벨에 따른 랜덤 유닛 보유(~레벨5:소형 ~레벨10:중형 ~레벨20:대형)
	.레벨에 따른 영웅 레벨 지정(레벨 - random(5))
	.레벨에 따른 영웅 스킬 레벨 지정
	.일단 더미계정은 장비는 없는걸로
	.레벨에 따른 구름 오픈 및 스팟 보유(2레벨 마다 구름 하나씩 깜)
	.랜덤한 자원 보유(모든자원 레벨x1만)
	.랜덤 승점(1~500점 사이로 골고루 분포)
	.더미 계정을 플레이하는 봇(스팟 공격)
		.레벨 1부터 스스로 플레이하는 봇이면 자원 수급도 시뮬레이션 할수 있다.
}

{
	#월드맵 UI 확정 => 가라데이터로 우선 구현해서 플레이 해본후 실용성을 검토하여 후반에 재작업
	.전투
		.어그로 시스템 => 기본기능 구현을 위해 뒤로 미룸
		.컨트롤
			.엄호 => 기본기능 구현을 위해 뒤로 미룸
			1.스킬사용UI와 관련 인디게이터
			.
		2.전투종료 처리
		.전투 관련 UI(인디게이터)기획 => 그래픽팀 작업 넘김
		3.전열 배치 씬
	.부대 레벨업 시스템 기획
	.유닛 특성 트리
	.영웅 장비 장착 및 능력치 반영 => UI코딩 할수있도록 넘김.
	.월드맵 구름영역 설정 => 일단 가라데이터로 모든 영역을 다 구성해서 플레이를 해보고 최후반부에 그래픽 작업하자.
}


어그로시스템
{
	.궁수를 때리고 있는 스피드를 아군근접이 떼어내기위한 목적
	.골렘같은 몸빵유닛이 대신맞아주기 위한 목적
	.어그로를 끌었다고 모든 부대로부터 일점사를 당하면 곤란하므로 
	 자신을 때리고 있는 적(근접)들중에서 어그로가 높은놈을 공격하도록 함
	.어그로로 인해 타겟이 변경되면 3초이내엔 수동으로 다시 바꿀수 없다.
	.근접유닛의 공격은 다른유닛들보다 어그로수치를 많이 올린다.
	.
}

가상전투시나리오
{
	#후방 레인지부대 암살
	.후방에 있는 적의 레인지부대를 먼저 조져야한다.
	.아군 스피드부대를 후방으로 보내 적 레인지부대를 공격하게 한다.
	.직선주로로 달리면 적1열의 근접에게 잡힌다.
	.대각선에 있는 적 레인지부대를 공격하게 해서 근접에게 걸리지 않도록 한다.
	.적근접은 적레인지부대를 엄호한다.
	.약점: 레인지부대옆에 근접이 엄호하고 있으면 효과가 없다.
	
	#중앙 힘싸움
	.근접부대를 1열에 세웟 돌격시킨다.
	.근접부대가 맞고 있는 동안 2열의 스피드나 3열의 레인지가 적 근접을 공격한다.
	.약점: 후방에 근접이 없어서 게릴라전술에 당한다.


}

유닛컨트롤 구현 전략
{
	.부대 터치하면 선택
		#유닛을 직접 터치하면 해당부대를 선택할 수 있다.
		#터치에 실패하면 해당위치가 부대의 반경인지 검사해서 선택한다.
		#부대가 선택이 되면 해당 부대원들의 발밑 그림자가 붉은색으로 바뀐다.
		.선택과 동시에 액티브스킬 쓸수 있는 버튼등장
			.선택모드 취소버튼
		@만약 유닛이 겹쳐있을때 터치했다면 겹친 부대의 영웅얼굴버튼들이 나타나고, 그 영웅얼굴을 누르면 스킬버튼이 다시 나타난다.
			@동시선택은 5개까지 유효하다(스킬버튼 크기에 따라 다름)
			@동시선택상태에서는 적군을 공격할수 없다. 선택된 영웅들중 하나를 골라서 단일선택으로 만들어야 한다.

	#부대선택중 적부대를 터치하면 그 부대를 공격하러 움직인다.
		.터치한 적부대는 1초간 발밑의 그림자가 붉은상태로 점멸한다.
	#부대선택중 바닥을 터치하면 그 위치로 이동한다.
		.바닥을 터치했음을 알리는 인디케이터가 등장한다.

	.부대선택중 아군부대를 터치하면 그 부대를 엄호한다. 
		.아군A부대 아군B부대 적A부대가 있고 적A부대가 아군A부대를 공격하는중이다.
		.아군B부대가 근접부대일 경우 아군A부대 근처로 이동한다.
		.아군A부대가 근접부대(적A부대)에게 공격당하면, 아군B부대는 적A부대를 공격한다.
		.부대마다 어그로수치를 가지고 있어서, 어그로높은부대가 공격하면 공격대상을 바꾸게 할수 있다.
		.적A가 어그로를 뺏겨서 아군B로 공격대상이 바꼈을때 수동조작으로 다시 아군A를 때리게 할수 있다.
		.그러나 이 수동조작은 3초에 한번씩 유효해서 그 이전에 사용할경우 타겟이 바뀌지 않는다.

	.적군을 찍어야 하는 상황(스킬)에서 선택가능한 부대의 중앙에 깃발이 나타난다.
		.깃발근처를 터치하면 부대지정
		.깃발은 영웅이름과 유닛아이콘이 있다.
	#적부대 강제공격을 명령했으면 해당부대가 죽기전까진 타겟을 바꾸지 않는다.(그러나 어그로로 인한 타겟변경은 있을수 있다)
	#적부대 강제공격중에는 반격을 하지 않는다.
}

원거리유닛의 근접공격전략
{
	.궁수가 쏘고 있던 부대가 궁수부대랑 붙으면 모든 궁수는 근접모드로 전환된다.
	.수동으로 다른 적부대를 지정해주면 원거리공격은 가능하다.
}

유닛 이동전략
{
	.부대단위로 접근 시킨다.
	.부대간에 일정거리가 되면 개별추적 단계로 전환한다.
	.서로 서서 싸울위치를 정해둔다.
		.먼저 프로세스가 돌아오는 유닛부터 타겟을 잡고 그 중간지점에서 싸울위치를 잡는다.
		.서로 위치가 정해졌으면 그 좌표는 양측다 고정시킨다.
		.다른 유닛의 프로세스에서 대상이 좌표가 고정되었는지를 보고 아직 고정안되었다면
		 중간위치에서 위치를 잡고 고정되었다면 그 고정좌표를 기준으로 2번째 유닛의 위치를 잡고 고정시킨다.
		.이때 원형 알고리즘으로 서도록 한다.
	.각자 위치로 달려간다.
	.목표지점까지 도달하면 대상과 싸운다.
}

UI코딩
{
	*각 씬별 핵심기능 구현 위주로 작업한다.
	.부대편성
	{
		.영웅리스트 나열
		.선택시 영웅 상세정보
		.영웅에 유닛 할당
		.유닛 리필
			.일단 전투로 손실된 유닛이 있을때 터치하면 일정자원을 소모하며 리필하는걸로 구현
			.테스팅해보고 나오는 문제점을 바탕으로 다시 수정한다.
		.영웅 경험치 업
			.영웅 책 먹이는 UI창 필요
			.인벤에 책 넣어두고 구현
			.아이템 인벤 구현 필요(****)-선행작업. 아이템 인벤구현
		.영웅 스킬업
			.+버튼 눌렀을때 스킬업하는 UI창 필요
			.스크롤 아이템 인벤에 넣어두고 구현
		.영웅 장비 선택 및 착용
			.슬롯을 눌렀을때 장비를 선택할 수 있는 창이 필요
			.능력치도 함께 볼수 있어야 한다.

	}
	아이패드 UI전략
	{
		.아이패드와 16:9기기를 동시에 무난히 지원하기 위해서는 모든 UI에 가급적 와꾸?가 없는 디자인이 좋다.
		.전투씬과 월드맵씬은 풀스크린을 쓴다.
		.월드맵씬 하위의 각 UI씬들은 좌우를 자른다.
		.기본적으로 아이패드 비율에도 무난한 UI로 디자인하고 16:9화면의 경우 보너스화면(?)이 더 보이는 식으로 한다.
		.부대편성씬
		{
			.16:9기기와 그렇지 않은 기기로 크게 나눈다.
			.16:9기기에서는 3줄짜리 버전으로 레이어를 맞추고, 다른 비율에서는 
			 1줄짜리 버전으로 중앙을 기준으로 정렬한다.
			.1줄짜리 버전의 경우 우측상세UI부분은 전체적으로 왼쪽으로 당겨지기만 한다.
			.뒷배경은 16:9기준으로 하고 비율이 짧은것은 양쪽을 잘라낸다.
			.배경이 양쪽으로 잘려도 상위ui레이어는 중앙을 기준으로 맞춰지도록 한다.
			.
		}
		.창고씬(비16:9버전의 경우)
		{
			.우측 아이템 설명창부분은 크기를 유지한채 왼쪽으로 당겨지기만 한다
			.왼쪽 스크롤부분은 4줄로 유지하되 좀더 오른쪽으로 타이트하게 붙도록 한다.
			.장비,전리품,기타 메뉴도 간격을 더 줄인다. 전체적으로 오른쪽으로 좀더 붙는다.
			.메뉴 배경이미지는 왼쪽을 그냥 잘리게 한다.
		}
	}
}




전투검증 전략
{
	.유닛들의 모든행동을 서버에서도 재플레이하면 서버에 부담이 너무 크다.
	.클라에서 서버로데이타를 보낼땐 누가 누구를 얼마로 때렸다의 정보만 보낸다.
	.서버에선 이 정보를 이용하여 타격만 리플레이해서 승패를 가린다.
	.한 1초단위로 프레임카운트 스탬프와 각 오브젝트의 hp정보를 같이 보내서 서버에서의 hp와 맞는지 검증한다.
}

구름 레이어 전략
{
	.영역별로 구름으로 채워진 이미지를 만든다.
	.게임내 툴에서 구름레이어에 배치를 하고 속성을 입력한다. {
		.구름찍기 모드로 전환
		.1,2번으로 구름모양을 선택해서 원하는 맵위에 왼클릭하면 구름 레이어에 등록
		.구름 오브젝트에는 자동으로 레이블번호가 붙고 이것으로 픽킹 가능해짐
		.구름 선택(픽킹)후 드래그 => 위치조절
		.구름 선택후 우클릭 => 속성창
		.속성창 {
			.몇레벨 이상에서 깔수 있는가.
			.깔수 있게 되었을때 얼마면 깔수 있는가.
			.특정 구름이 먼저 오픈되어야만 오픈할수 있는 선행오픈구름이 있는가.
			.이 구름을 까면 오픈되는 스팟은 어떤 스팟들인가.(스팟아이디)
		}
	}
	.게임에서는 구름한덩어리가 객체가 된다.
	// 여기까지가 1차 구현
	.배경맵을 32혹은 64단위 타일단위로 쪼개서 draw를 한다.
	.구름아래 가려지는 부분을 계산해서 draw하지 않는 방식으로 최적화 한다. 혹은 z버퍼 사용?
	구현
	{
		XScrollView
			XWndCloudLayer
				XWndCloud
					XWndButton
	}
}

붐비치 진행
{
	.첨에 npc스팟 1개, 영역확장가능 3군데(각각 npc스팟 하나씩 숨어있음)
	.레이더 업그레이드하면 4군데 확장영역이 더생김.
}


스팟 등장 전략
{
	.바로 옆에 NPC스팟.
	.새영역 열림(2레벨, 돈필요)
	.유저스팟 1
	.새영역 열림(2레벨, 돈필요)
	.유저스팟 2
	.새영역 열림
	.보석1(말뚝) 열림-NPC부대 처치후 차지
	. 보석1-유황1-보석2-유황2-만드레이크1-보석3-요일스팟-유황3-만드레이크2-스페셜스팟-만드레이크3
}



요일별 스팟 구현
{
	.접속하면 일단 생성되어 있는 요일스팟을 찾는다.
	.이 요일스팟이 오늘의 요일스팟 타입하고 다르면 일단 스팟 해제.
	.새 요일 스팟을 랜덤위치에 생성.
	.자정으로부터 몇시간이 지났는지 계산하여 스팟에 타이머를 세팅한다.
	.클라로 스팟 정보를 보낸다.

}





* 자원지 공유 알고리즘
{
	.레벨이 증가하거나 시야가 넓어지는등의 이벤트로 새 공유스팟이 발생해야
	 하는 상황이 생기면 서버측에 새스팟을 생성하는 이벤트가 발생한다.
	.서버에서는 스팟매니저에 새 스팟을 요구하고 스팟매니저는 이를 받아
	 새 스팟을 만들거나 짝이없는 스팟을 찾아 그 아이디를 보낸다. 
	.	 


	 * 스팟DB
	 보석광산 스팟 리스트
	 아이디 유저1 유저2
	 1      1     0
}


스팟DB를 따로 안두는 경우의 구현방법
{
	.보석광산을 얻었다.
	.보석광산 스팟의 레벨을 1로 초기화시킨다
	.광산의 소유는 일단 내것이다.(상대는 비어있다)
	.광산으로 수입을 얻는다.
	.다른 누군가(A)가 보석광산을 새로 얻거나, 아니면 "상대바꾸기"를 했다
	.매칭 룰에 의해 내가 선택이 되었다.
	.내 보석광산정보를 가져간다.
	.A가 내 광산을 공격한다.
	.A는 광산의 idOwner의 정보로 DB에서 내 정보를 찾아서 군대정보를 받아서
	 전투를 한다
	.A가 지면 내 DB정보에서 광산의 방어도를 깎는다.
	.A가 이기면 내 DB에 있던 광산의 정보를 A의 DB로 옮긴다. 
	.내 DB에 광산정보에는 idOwner에 A의 id로 바꿔넣는다.

	.내가 "상대바꾸기"를 했다
	.매칭룰에 의해 적절한 상대를 DB에서 찾는다.
	.점수도 비슷하고 광산에 상대도 없어야 한다.
	.그 대상의 광산정보를 받아온다.
	.만약 적절한 상대가 DB에서 없다면 새 광산스팟이 배정되고 내소유가 된다.
	.A의 광산의 상대아이디에선 내 아이디를 뺀다. 
	.A의 광산의 레벨을 다시 초기화 할지는 옵션.
	.만약 A가 온라인 상태라면 온라인 상태인 유저에게 직접 전달해야 할듯?

	DB구성(Account내에서)
	점수, 보석광산1 레벨, 보석광산1 방어도, 보석광산1의 상대id, 
	
}

1:다 스팟의 경우 구현방법(스팟DB따로 안두는 방식)
{
	#기본개념
	 .소유자가 광산의 정보를 갖는다.
	 .공격자가 소유자의 광산정보를 DB에서 받아다 쓴다.
	#구현
	 .밭을 얻었다.
	 .DB를 뒤져서 내 점수대인 사람을 찾고 밭 정보에 껴들 자리가 있는 사람을 찾는다.
	 .있으면 그사람 아이디 및 밭 정보를 받아온다.
	 .없으면 내 계정에 새 밭을 만들고 내 소유로 한다.
}



광산에 필요한 컬럼
광산1소유자 광산1상대자 광산1레벨 광산1방어도, 광산1방어군단idx, 광산1매칭시간(마지막전투시간), 
광산2.... 
만약 정찰이나 공격을 했는데 상대광산정보에 상대자가 내가 아니면
작업을 취소하고 내광산을 독자적으로 갖도록 만들고 다시 매칭되기를 기다린다.


메모리상에서는 XSpotCastle에 값을 가지고 있다가 DB에 저장할때는 XSpotCastle
객체를 꺼내서 그안에 값을 저장한다. 저장은 별도의 DB컬럼에 저장한다.
로딩할때는 월드객체를 먼저 읽고 보석광산 정보를 컬럼에서 읽어서
보석광산 객체를 추가로 만든다.


/*
	군단정보 로딩 방식
	.full serialize 바이너리를 읽는다.
	.별도의 XLegion객체를 생성해서 풀어놓는다.
	.full버전 XLegion객체 데이타를 link버전 XLegion객체로 컨버트 한다.,
	.컨버트한 군단객체를 계정데이타로 쓴다.
*/


		float multiplyLocalMove = 1.f;
		if( GettimerLocalMove().IsOn() )
		{
			if( GettimerLocalMove().IsOver() == FALSE )
			{
				// 현재 위치에서 분대내자리까지의 벡터
				XE::VEC3 vDist = m_pUnit->GetvwPos() - ( m_pUnit->GetpSquadObj()->GetvwPos() + m_pUnit->GetvLocalFromSquad() );
				XE::VEC3 vwCurr = m_vwLocalMoveStart + vDist * GettimerLocalMove().GetSlerp();
				m_pUnit->SetvwPos( vwCurr );
				multiplyLocalMove = 2.f;	// 분대내자리로 이동중에는 이동속도를 두배로 한다.
			}
			else
				GettimerLocalMove().Off();

		}
		{
			// 추적중엔 타겟방향으로 바라보게 한다.
			DoDirToTarget( m_pUnit->GetvwTarget() );

			// 약간의 딜레이후에 출발한다.
			if( m_timerDelay.IsOver() )
			{
				m_timerDelay.Off();
				m_pUnit->GetpSprObj()->SetAction( ACT_RUN );
			}
			if( m_pUnit->GetpSprObj()->GetActionID() == ACT_RUN )
			{
				BOOL bArrive = FALSE;
				XE::VEC3 vDist = m_pUnit->GetvwTarget() - m_pUnit->GetvwPos();
				vDist.Abs();
				{
					m_vwDstTarget = m_pUnit->GetvwTarget();
					// 이번턴에 이동량을 계산한다.
					XE::VEC3 vDelta;
					bArrive = XBaseUnit::sGetMoveDstDelta( m_pUnit->GetvwPos(), m_vwDstTarget, m_pUnit->GetSpeedMoveForPixel(), &vDelta );
					m_pUnit->AddDelta( vDelta );
					m_pUnit->AddPos( vDelta );
				}
				if( bArrive )
				{
					// 일단 대기모션으로 전환.
					m_pUnit->GetpSprObj()->SetAction( ACT_IDLE1 );
				}
			}
		}
		// 1배속일때 movSpeedNormal픽셀을 간다고 가정해서 속도에 따라 애니메이션 속도를 조절한다.
		float multiply = ( m_pUnit->GetSpeedMovePerSec() * multiplyLocalMove ) / m_pUnit->GetpProp()->movSpeedNormal;
		m_pUnit->GetpSprObj()->SetmultiplySpeed( multiply );



XD3DView::Draw 0.98 54613 0 0 1
XClientMain::FrameMove 0.04 2424 0 0 2
+XGame::Process 1.00 2415 0 0 3
++XBattleField::Process 0.99 2385 0 0 4
+++XEObjMng::FrameMove 0.70 1669 0 0 5
XClientMain::Draw 0.30 16595 0 0 2
+XEObjMng::Draw 0.89 14784 0 0 3
++select 0.12 1722 0 0 4
+++sort 0.21 357 0 0 5
++XEObjMngWithType::DrawVisible 0.88 13054 0 0 4
+++draw shadow 0.00 17 0 0 5
+++projection 0.00 0 0 0 5
+++draw each 0.00 25 0 0 5
+++XBaseUnit::Draw 1.00 25 0 0 6
XWndButtonDebug::Draw 0.03 561 0 0 3
XClientMain::DrawDebugInfo 0.00 0 0 0 3

XD3DView::Draw 0.97 54097 0 0 1
+XClientMain::FrameMove 0.05 2880 0 0 2
++XGame::Process 1.00 2872 0 0 3
+++XBattleField::Process 0.99 2846 0 0 4
++++XEObjMng::FrameMove 0.74 2107 0 0 5
+XClientMain::Draw 0.30 16322 0 0 2
++XEObjMng::Draw 0.92 15041 0 0 3
+++select 0.14 2157 0 0 4
++++select-sel 0.00 2 0 0 5
++++select-sort 0.18 383 0 0 5
+++XEObjMngWithType::DrawVisible 0.86 12879 0 0 4
++++draw shadow 0.00 11 0 0 5
++++projection 0.00 0 0 0 5
++++draw each 0.00 17 0 0 5
++++XBaseUnit::Draw 1.00 17 0 0 6
+++++draw hit 0.82 14 0 0 7
+++++draw bar 0.47 8 0 0 7
XWndButtonDebug::Draw 0.02 394 0 0 3
XClientMain::DrawDebugInfo 0.00 0 0 0 3

XD3DView::Draw 0.97 54409 0 0 1
+XClientMain::FrameMove 0.05 2989 0 0 2
XGame::Process 1.00 2980 0 0 3
XBattleField::Process 0.99 2953 0 0 4
XEObjMng::FrameMove 0.74 2195 0 0 5
+XClientMain::Draw 0.37 20101 0 0 2
XEObjMng::Draw 0.93 18603 0 0 3
select 0.13 2489 0 0 4
select-sel 0.00 3 0 0 5
select-sort 0.19 466 0 0 5
XEObjMngWithType::DrawVisible 0.87 16107 0 0 4
draw shadow 0.00 13 0 0 5
projection 0.00 0 0 0 5
draw each 0.00 21 0 0 5
XBaseUnit::Draw 0.95 20 0 0 6
draw unit 0.85 17 0 0 7
draw bar 0.45 9 0 0 7
draw hit 0.85 17 0 0 7
XWndButtonDebug::Draw 0.02 464 0 0 3
XClientMain::DrawDebugInfo 0.00 0 0 0 3


// 평타나 스킬로 적을 때릴때마다 호출되는 이벤트
// this가 피격자
/*
유닛::OnMeleeHitToTarget( 공격자 )
{
	OnSkillEventMeleeHitFromAttacker( 공격자, 근접타격 )
}

SkillReceiver::OnSkillEventMeleeHitFromAttacker( XSkillReceiver *공격자, 공격타입 )
{
	버프루프( 버프 )
	{
		버프->OnSkillEventMeleeHitFromAttacker( this, 공격자, 피격자, 공격타입 );
	}
}

버프::OnSkillEventMeleeHitFromAttacker( 오너, 공격자, 피격자, 공격타입 )
{
	이펙트루프( 이펙트 )
	{
		if( 이펙트->발동시점 == 근접타격 )
		{
			if( 이펙트->발동대상 == 피격자 )
				ApplyInvokeEffect( 이펙트, 오너, 발동대상파람, 피격자 );
		}
	}
}

버프::ApplyInvokeEffect( 이펙트, 오너, 시전대상 )
{
	발동대상뽑기( &ary, 이펙트->발동대상파람, 시전대상 )
}

GetInvokeTarget( ary, 발동대상파람, p시전대상 )
{
	switch( 발동대상파람 )
	case 시전대상:
	case 피격자:		// 피격이펙트때는 시전대상에 피격자를 넣어야함.
		ary.add( p시전대상 );
	case 시전대상_주변:
	case 피격자_주변:
		ary.Add( p시전대상 주변 )

}
*/



		switch( pBaseSpot->type )
		{
		case XGAME::xSPOT_CASTLE: {
			auto pProp = static_cast<XPropWorld::xCASTLE*>( pBaseSpot );
			pProp->numWood = (float)dlg.m_numProduce[ 0 ];
			pProp->numIron = (float)dlg.m_numProduce[ 1 ];
		} break;
		case XGAME::xSPOT_JEWEL: {
			auto pProp = static_cast<XPropWorld::xJEWEL*>( pBaseSpot );
		} break;
		case XGAME::xSPOT_SULFUR: {
			auto pProp = static_cast<XPropWorld::xSULFUR*>( pBaseSpot );
		} break;
		case XGAME::xSPOT_MANDRAKE: {
			auto pProp = static_cast<XPropWorld::xMANDRAKE*>( pBaseSpot );
		} break;
		case XGAME::xSPOT_NPC: {
			auto pProp = static_cast<XPropWorld::xNPC*>( pBaseSpot );
		} break;
		case XGAME::xSPOT_DAILY: {
			auto pProp = static_cast<XPropWorld::xDaily*>( pBaseSpot );
		} break;
		case XGAME::xSPOT_SPECIAL: {
			auto pProp = static_cast<XPropWorld::xSpecial*>( pBaseSpot );
		} break;
		case XGAME::xSPOT_CAMPAIGN: {
			auto pProp = static_cast<XPropWorld::xCampaign*>( pBaseSpot );
		} break;
		case XGAME::xSPOT_VISIT: {
			auto pProp = static_cast<XPropWorld::xVisit*>( pBaseSpot );
		} break;
		default:
			XBREAK(1);
			break;
		}

		// 	XWnd *pWnd2 = Find("root.spot");
// 
// 	m_Layout.CreateLayout("spotclickselect", pWnd2);
// 
// 	pPopup = Find("img.world.center");
// 		
// 	if (pPopup)
// 	{
// 		if (bRecon)
// 		{
// 			xSET_BUTT_HANDLER_PARAM(this, "butt.world.recon", pPopup, &XSceneWorld::OnReconSpot, idSpot);
// 		}
// 		else
// 			xSET_ENABLE( this, "butt.world.recon", FALSE );
// 
// 		if (bAttack)
// 		{
// 			xSET_BUTT_HANDLER_PARAM(this, "butt.world.attack", pPopup, &XSceneWorld::OnAttackSpot, idSpot);
// 			xSET_ACTIVE(this, "img.world.attack", FALSE);
// 		}
// 		else
// 		{
// 			xSET_SHOW(this, "img.world.attack", TRUE);
// 		}
// 
// 		if (bCollect)
// 		{
// 			xSET_BUTT_HANDLER_PARAM(this, "butt.world.collect", pPopup, &XSceneWorld::OnCollectSpot, idSpot);
// 			xSET_ACTIVE(this, "img.world.collect", FALSE);
// 		}
// 		else
// 		{
// 			xSET_SHOW(this, "img.world.collect", TRUE);
// 		}
// 		
// 
// 		XWnd *pWnd = Find(idSpot);
// 		if (pWnd)
// 		{
// 			if (pWnd2)
// 			{
// 				pPopup->SetPosLocal(pWnd->GetPosLocal() - pPopup->GetSizeLocal() / 2);
// 			}
// 		}
// 
// 		//xSET_BUTT_HANDLER(pWnd2, "img.world.center", &XSceneWorld::OnCloseCenter);
// 	}

/*
상태:
  .초기화상태: 모든 값 초기화. 타이머는 멈춰 있음
  .오픈상태: 레이드 시작, 타이머 흐르기 시작(닫힘상태에서 길마가 오픈)
  .오픈-클리어상태: 레이드 클리어상황. 시간은 남아있음
Recv캠페인정보요청()
	if( 오픈상태인가 )
		if( 시간이 다되었는가 && 현재도전중인 유저가 없는가 )
			초기화상태로 전환
		else
			현재 상태 그대로 보냄;
		end
	else
		현재상태 그대로보냄()
	end
end
Recv캠페인시작요청()
	if( 초기화상태인가 )
		오픈상태로전환();
	else
		에러리턴(아직 캠페인이 끝나지 않음)
	end
end
Recv스테이지진입()
	if( 오픈상태인가 )
		if( 시간이 다되었는가 )
			초기화상태로전환
		else
			결과 = 진입시도()
			if( 결과 == 성공 )
				스테이지락
		end
	else
		에러리턴(오픈상태가 아님)
	end
end
Recv진입해제
	if( 오픈상태인가 )
		진입해제
		if( 시간이 다되었는가 )
			초기화상태로전환
		end
	else
		에러리턴(오픈상태가 아님)
	end
end

  if( 스팟을 열었는가 )
	if( 오픈상태인가 )
		if( 시간이 다되었다 )
			초기화상태로 바꿈.
		end
	else if( 초기화상태인가)
		
	end
  end
  if( 초기화상태인가 )
	if( 길마가 시작을 함 )
		오픈상태로 전환
	end
  end
*/



2>c:\xuzhu_work\project\iphone_zero\testx\app\pc_prj\testx\testx\xsocketforclient.cpp(36): error C2259: 'XClientConnection' : 추상 클래스를 인스턴스화할 수 없습니다.
2>          다음 멤버가 원인입니다.
2>          'BOOL XEWinConnectionInServer::ProcessPacket(DWORD,ID,XPacket &)' : abstract입니다.
2>          c:\xuzhu_work\project\iphone_zero\xe\xframework\server\xwinconnection.h(108) : 'XEWinConnectionInServer::ProcessPacket' 선언을 참조하십시오.
2>  XSAccount.cpp
2>  XMainDelegate.cpp
2>  XMain.cpp
2>  XGameUserMng.cpp
2>  XGameUser.cpp
2>c:\xuzhu_work\project\iphone_zero\testx\app\pc_prj\testx\testx\xgameuser.cpp(44): error C2512: 'XPacket' : 사용할 수 있는 적절한 기본 생성자가 없습니다.
2>  XGame.cpp
2>  XClientConnection.cpp
2>  check this
2>c:\xuzhu_work\project\iphone_zero\testx\app\pc_prj\testx\testx\xclientconnection.cpp(75): warning C4065: switch문에 'default'가 있으나 'case' 레이블이 없습니다.

idPlayer: 207794001
idEncounter: 208721001
numSulfur: 19925
idSpot: 649

유황스팟 {
	활성상태 {
		약탈기록이 남아있으면 "약탈기록"버튼이 활성화 된다.
		약탈기록이 없으면 "약탈기록"버튼은 나타나긴하나 비활성 된다.
		"약탈기록"버튼을 누르면 가운데 UI가 변경되고 약탈기록이 스크롤뷰에 보여진다.
		이때 "약탈기록"버튼은 체크상태(글로우)가 된다.
		다시한번 "약탈기록"버튼을 누르면 이전상태로 돌아간다.
		약탈기록은 로그아웃 하기전까지는 계속 남아있는다.
	}
	비활성상태 {
		약탈기록이 남아있으면 곧바로 가운데 UI에 약탈기록이 스크롤뷰로 보여진다.
		버튼은 리젠버튼만 있다.
	}
}

3600:700 = x : 1
3600 / 700

8, 11, 14, 17


//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------

float4x4 mViewProj : mViewProj;
float4x4 mWorld : mWorld;
texture Sprite;
float fOpacity;
float col_r;
float col_g;
float col_b;

//-----------------------------------------------------------------------------

struct VS_INPUT {
	float4 Position : POSITION;
//    float4 Diffuse : COLOR0;
	float2 TexCoord0 : TEXCOORD0;
};

struct VS_OUTPUT {
	float4 Position  : POSITION;
	float4 Diffuse : COLOR0;
	float2 TexCoord0 : TEXCOORD0;
};

//-----------------------------------------------------------------------------

sampler SpriteSampler = sampler_state
{
	Texture = <Sprite>;
	MinFilter = Linear;  
	MagFilter = Linear;
	MipFilter = None;
	AddressU  = Clamp;
	AddressV  = Clamp;
};

//-----------------------------------------------------------------------------

VS_OUTPUT MainVS(VS_INPUT IN)
{
	VS_OUTPUT OUT;
	
	float4 pos;
	pos = mul( IN.Position, mWorld );
	pos.z = 0;										// 3d를 2d로 쓸때 x,y,z중 z는 사용하지 않는데 Y축 회전을시키면 z에 값이 생겨버려서 출력이 안되는 문제가 있음 그래서 z는 강제로 0으로 맞춰줌
	OUT.Position = mul( pos, mViewProj );
	OUT.Diffuse = float4( 1, 1, 1, 1 );
	OUT.TexCoord0 = IN.TexCoord0;

	return OUT;
}

//-----------------------------------------------------------------------------
float4 MainPS(VS_OUTPUT IN) : COLOR 
{
	float4 color;
	color = tex2D( SpriteSampler, IN.TexCoord0 );
	color.a = fOpacity * color.a;
	color.r = color.r * col_r;
	color.g = color.g * col_g;
	color.b = color.b * col_b;
	return color;
}

//-----------------------------------------------------------------------------

technique RenderSprite
{
	pass P0
	{
		VertexShader = compile vs_2_0 MainVS();
		PixelShader = compile ps_2_0 MainPS();
		
		ZEnable          = False;
		AlphaBlendEnable = True;
//		SrcBlend = SRCALPHA;
//		DestBlend = INVSRCALPHA;
		Lighting         = False;
//        CullMode         = CCW;
	
//        TexCoordIndex[0] = 0;
//        TexCoordIndex[1] = 1;
//       TextureTransformFlags[0] = Projected;
//        TextureTransformFlags[1] = Projected;
	}
}

//-----------------------------------------------------------------------------

02-26 09:37:07.848: D/xuzhu(31227): onActivityResult(10001,-1,Intent { (has extras) }
02-26 09:37:07.858: D/xuzhu(31227): GoogleIAP:Purchase finished: IabResult: Success (response: 0:OK), purchase: PurchaseInfo(type:inapp):{"orderId":"GPA.1331-5143-1048-14732","packageName":"com.mtricks.caribe","productId":"inapp_cash00001","purchaseTime":1456447023898,"purchaseState":0,"developerPayload":"hello xuzhu mTricks","purchaseToken":"ojgbdhaekimnengjpnjdoleo.AO-J1OzfIRm_UMwcHB2_8Bf6sVQw3OzmNhKLqYXj3ig2Y-SkZmVjV8toBTqBMHZidro3INHopzveRRRrffNzs1RADrJZoGe4xxcKV-S4qYCD3wZ0vuHlVup5yl2MJnLqUCYyuLZ-Zu3t"}
02-26 09:37:07.858: D/xuzhu(31227): GoogleIAP:Purchase successful.
02-26 09:37:07.858: D/xuzhu(31227): GoogleIAP:Purchase item. Starting item consumption.
02-26 09:37:07.858: D/xuzhu(31227): IAP:onActivityResult handled by IABUtil.
02-26 09:37:07.868: D/xuzhu(31227): nativeInit:1920x1080
02-26 09:37:07.868: D/xuzhu(31227): XE::OnResumeHandler()
02-26 09:37:07.868: D/xuzhu(31227): XE::RestoreDevice
02-26 09:37:07.868: D/xuzhu(31227): XClientMain::OnResumeHandler()
02-26 09:37:07.868: D/xuzhu(31227): restore start
02-26 09:37:07.868: D/xuzhu(31227): restore device resource
02-26 09:37:07.868: D/xuzhu(31227): max texture size:4096
02-26 09:37:07.868: D/xuzhu(31227): base shader loading....
02-26 09:37:07.868: D/xuzhu(31227): texture shader loading....
02-26 09:37:07.868: D/xuzhu(31227): gray shader loading....
02-26 09:37:07.868: D/xuzhu(31227): color shader loading....
02-26 09:37:07.868: D/xuzhu(31227): onecolor shader loading....
02-26 09:37:07.878: D/xuzhu(31227): blurH shader loading....
02-26 09:37:07.878: D/xuzhu(31227): blurV shader loading....
02-26 09:37:07.878: D/xuzhu(31227): restore font
02-26 09:37:08.018: D/xuzhu(31227): restore image
02-26 09:37:09.118: D/xuzhu(31227): GoogleIAP:Consumption finished. Purchase: PurchaseInfo(type:inapp):{"orderId":"GPA.1331-5143-1048-14732","packageName":"com.mtricks.caribe","productId":"inapp_cash00001","purchaseTime":1456447023898,"purchaseState":0,"developerPayload":"hello xuzhu mTricks","purchaseToken":"ojgbdhaekimnengjpnjdoleo.AO-J1OzfIRm_UMwcHB2_8Bf6sVQw3OzmNhKLqYXj3ig2Y-SkZmVjV8toBTqBMHZidro3INHopzveRRRrffNzs1RADrJZoGe4xxcKV-S4qYCD3wZ0vuHlVup5yl2MJnLqUCYyuLZ-Zu3t"}, result: IabResult: Successful consume of sku inapp_cash00001 (response: 0:OK)
02-26 09:37:09.118: D/xuzhu(31227): GoogleIAP:Signature: etTgzD99U2f5UyEncC1BECCNNpWpFef5mFXOvebYqXsSguopFia6EIfP6A+Hf0sY04azuZdHN3rqWfGo1qgpKLSoYNmlIcuG3BV9E/PE3GklQC6UpCrSPFLKxtZUdRh/W9xuDEKjQMUUQawxeTJW8ydebZPqzrO4TIQxQj6vwjtjcjqhzN8zqyHo8tdZ8KOPUse9pvZZOCQwWEOfG+nP830LxXrg4DlwjxCspHLy7VoPh5OqVpNly7CTcZobSf2dAWZjZsd3X19vtZ8cqDEUUZTJtABHqKjITf/DGziod/uy3UgDYjKKD1/gH4HU560D0BPXeAPW0vrzJgO1Fc6uDQ==
02-26 09:37:09.128: D/xuzhu(31227): sku:inapp_cash00001
02-26 09:37:09.128: D/xuzhu(31227): token:etTgzD99U2f5UyEncC1BECCNNpWpFef5mFXOvebYqXsSguopFia6EIfP6A+Hf0sY04azuZdHN3rqWfGo1qgpKLSoYNmlIcuG3BV9E/PE3GklQC6UpCrSPFLKxtZUdRh/W9xuDEKjQMUUQawxeTJW8ydebZPqzrO4TIQxQj6vwjtjcjqhzN8zqyHo8tdZ8KOPUse9pvZZOCQwWEOfG+nP830LxXrg4DlwjxCspHLy7VoPh5OqVpNly7CTcZobSf2dAWZjZsd3X19vtZ8cqDEUUZTJtABHqKjITf/DGziod/uy3UgDYjKKD1/gH4HU560D0BPXeAPW0vrzJgO1Fc6uDQ==
02-26 09:37:09.128: D/xuzhu(31227): price₩1,000
02-26 09:37:09.128: D/xuzhu(31227): time=1456447023898
02-26 09:37:09.128: D/xuzhu(31227): OrderId=GPA.1331-5143-1048-14732
02-26 09:37:09.128: D/xuzhu(31227): XE::OnPurchaseFinishedConsume:inapp_cash00001
02-26 09:37:09.128: D/xuzhu(31227): OnPurchaseFinishedConsume: sku=inapp_cash00001 token=etTgzD99U2f5UyEncC1BECCNNpWpFef5mFXOvebYqXsSguopFia6EIfP6A+Hf0sY04azuZdHN3rqWfGo1qgpKLSoYNmlIcuG3BV9E/PE3GklQC6UpCrSPFLKxtZUdRh/W9xuDEKjQMUUQawxeTJW8ydebZPqzrO4TIQxQj6vwjtjcjqhzN8zqyHo8tdZ8KOPUse9pvZZOCQwWEOfG+nP830LxXrg4DlwjxCspHLy7VoPh5OqVpNly7CTcZobSf2dAWZjZsd3X19vtZ8cqDEUUZTJtABHqKjITf/DGziod/uy3UgDYjKKD1/gH4HU560D0BPXeAPW0vrzJgO1Fc6uDQ== orderId=GPA.1331-5143-1048-14732 price=1000.000000 purchaseTime=1456447023898
02-26 09:37:09.128: D/xuzhu(31227): GoogleIAP:Consumption successful. Provisioning.inapp_cash00001
02-26 09:37:09.128: D/xuzhu(31227): GoogleIAP:End consumption flow.
02-26 09:37:10.438: D/xuzhu(31227): restore sprite
02-26 09:37:10.568: D/xuzhu(31227): restore game
02-26 09:37:10.578: D/xuzhu(31227): restore end
02-26 09:37:10.578: D/xuzhu(31227): prop/text_ko.txt....token.LoadFile() success
02-26 09:37:10.588: D/xuzhu(31227): text loading success.....prop/text_ko.txt. lastID:90007 num=3116
02-26 09:37:10.588: D/xuzhu(31227): XFacebook::GetRequestProfileImage: fbid=1097088886976908
02-26 09:37:10.588: D/xuzhu(31227): CrashHandler.cpp(48) SignalHandler():
02-26 09:37:10.588: D/xuzhu(31227):     crash! write dump.bin2

{"orderId":"GPA.1331-5143-1048-14732","packageName":"com.mtricks.caribe","productId":"inapp_cash00001","purchaseTime":1456447023898,"purchaseState":0,"developerPayload":"hello xuzhu mTricks","purchaseToken":"ojgbdhaekimnengjpnjdoleo.AO-J1OzfIRm_UMwcHB2_8Bf6sVQw3OzmNhKLqYXj3ig2Y-SkZmVjV8toBTqBMHZidro3INHopzveRRRrffNzs1RADrJZoGe4xxcKV-S4qYCD3wZ0vuHlVup5yl2MJnLqUCYyuLZ-Zu3t"}
{"orderId":"GPA.1331-5143-1048-14732","packageName":"com.mtricks.caribe","productId":"inapp_cash00001","purchaseTime":1456447023898,"purchaseState":0,"developerPayload":"hello xuzhu mTricks","purchaseToken":"ojgbdhaekimnengjpnjdoleo.AO-J1OzfIRm_UMwcHB2_8Bf6sVQw3OzmNhKLqYXj3ig2Y-SkZmVjV8toBTqBMHZidro3INHopzveRRRrffNzs1RADrJZoGe4xxcKV-S4qYCD3wZ0vuHlVup5yl2MJnLqUCYyuLZ-Zu3t"}
etTgzD99U2f5UyEncC1BECCNNpWpFef5mFXOvebYqXsSguopFia6EIfP6A+Hf0sY04azuZdHN3rqWfGo1qgpKLSoYNmlIcuG3BV9E/PE3GklQC6UpCrSPFLKxtZUdRh/W9xuDEKjQMUUQawxeTJW8ydebZPqzrO4TIQxQj6vwjtjcjqhzN8zqyHo8tdZ8KOPUse9pvZZOCQwWEOfG+nP830LxXrg4DlwjxCspHLy7VoPh5OqVpNly7CTcZobSf2dAWZjZsd3X19vtZ8cqDEUUZTJtABHqKjITf/DGziod/uy3UgDYjKKD1/gH4HU560D0BPXeAPW0vrzJgO1Fc6uDQ==
etTgzD99U2f5UyEncC1BECCNNpWpFef5mFXOvebYqXsSguopFia6EIfP6A+Hf0sY04azuZdHN3rqWfGo1qgpKLSoYNmlIcuG3BV9E/PE3GklQC6UpCrSPFLKxtZUdRh/W9xuDEKjQMUUQawxeTJW8ydebZPqzrO4TIQxQj6vwjtjcjqhzN8zqyHo8tdZ8KOPUse9pvZZOCQwWEOfG+nP830LxXrg4DlwjxCspHLy7VoPh5OqVpNly7CTcZobSf2dAWZjZsd3X19vtZ8cqDEUUZTJtABHqKjITf/DGziod/uy3UgDYjKKD1/gH4HU560D0BPXeAPW0vrzJgO1Fc6uDQ==



02-26 15:27:58.950: D/xuzhu(22728): java Callback_OnClickedBuyItem.inapp_cash00001payload:A90D9CD9182C493D93BAD232175AD73A
02-26 15:28:00.220: D/xuzhu(22728): GoogleIAP:onBuyProduct:price:₩1,000
02-26 15:28:00.310: D/xuzhu(22728): successed call [Callback_OnClickedBuyItem]
02-26 15:28:00.320: D/xuzhu(22728): layout create: key=commontextpopup
02-26 15:28:00.360: D/xuzhu(22728): FTGL:texture dimensions: 1024 1024
02-26 15:28:00.360: D/xuzhu(22728): nativeOnPause
02-26 15:28:00.360: D/xuzhu(22728): java stopBackgroundMusic
02-26 15:28:00.360: D/xuzhu(22728): XClientMain::OnPauseHandler()
02-26 15:28:00.360: D/xuzhu(22728): XGame::OnPause
02-26 15:28:00.360: D/xuzhu(22728): XGame::DestroyGameResource
02-26 15:28:00.360: D/xuzhu(22728): Destroy PropBgObj
02-26 15:28:00.360: D/xuzhu(22728): XGameCommon::DestroyCommon()
02-26 15:28:00.370: D/xuzhu(22728): --XGameCommon::DestroyCommon()
02-26 15:28:00.370: D/xuzhu(22728): --XGame::DestroyGameResource
02-26 15:28:18.470: D/xuzhu(22728): onActivityResult(10001,-1,Intent { (has extras) }
02-26 15:28:18.490: D/xuzhu(22728): GoogleIAP:Purchase finished: IabResult: Success (response: 0:OK), purchase: PurchaseInfo(type:inapp):{"orderId":"GPA.1365-4718-4475-61137","packageName":"com.mtricks.caribe","productId":"inapp_cash00001","purchaseTime":1456468094848,"purchaseState":0,"developerPayload":"A90D9CD9182C493D93BAD232175AD73A","purchaseToken":"ofdehcknhioepaddlmioheeh.AO-J1OygsoUPK4pg8pDyXsODugY6WWxOZdOqhxbkT0ua-vtNZYfvb4Nj5J95_33qKaMkCHAeyFMbvPZYhnrc035CM_8T9jRybdRNtqjDQZBMy9y06gjQ3R87FaG3EDWl81t3ZohVkgM-"}
02-26 15:28:18.490: D/xuzhu(22728): GoogleIAP:Purchase successful.
02-26 15:28:18.490: D/xuzhu(22728): excute Java_com_mtricks_xe_XRenderer_nativeOncbOnClickedBuyItem
02-26 15:28:18.490: D/xuzhu(22728): Java_com_mtricks_xe_XRenderer_nativeOncbOnClickedBuyItem: receipt="PurchaseInfo(type:inapp):{"orderId":"GPA.1365-4718-4475-61137","packageName":"com.mtricks.caribe","productId":"inapp_cash00001","purchaseTime":1456468094848,"purchaseState":0,"developerPayload":"A90D9CD9182C493D93BAD232175AD73A","purchaseToken":"ofdehcknhioepaddlmioheeh.AO-J1OygsoUPK4pg8pDyXsODugY6WWxOZdOqhxbkT0ua-vtNZYfvb4Nj5J95_33qKaMkCHAeyFMbvPZYhnrc035CM_8T9jRybdRNtqjDQZBMy9y06gjQ3R87FaG3EDWl81t3ZohVkgM-"}" Signature="gSf63oWarrbDrdbs4giXWRa8G9eiwfTltX8HIakaecilAVyJ8UIpXnaRfHyk9KLtTJPhnoub7KrIaTBiY23DquZULeaN/MGXodwZ52XV3Ieu72VYl78DYX7TJ1NK9Nbpoc4+U5bzbNWqdMVArLKDOFe6fC8Ha4gdQGv+xtaneUgDKZcmCkHshGDYvz2LTXnHSBHkSPbM5HSM5DR1Ycevbr7xbKxo27Nbd2F9n6LRZ+8rf8asmzrFrfuta9EdBTEa5AsCHHFAwdwYcF5dEZS37+xXP+dcqNrlhHSepOiEDqCNIILHGckDN660vUYQXNc/IkzA//6TNqRJvDcnkby6ZA=="
02-26 15:28:18.490: D/xuzhu(22728): IAP:onActivityResult handled by IABUtil.
02-26 15:28:18.500: D/xuzhu(22728): nativeInit:1920x1080
02-26 15:28:18.500: D/xuzhu(22728): XE::OnResumeHandler()
02-26 15:28:18.500: D/xuzhu(22728): XE::RestoreDevice
02-26 15:28:18.500: D/xuzhu(22728): XClientMain::OnResumeHandler()
02-26 15:28:18.500: D/xuzhu(22728): restore start
02-26 15:28:18.500: D/xuzhu(22728): restore device resource
02-26 15:28:18.500: D/xuzhu(22728): max texture size:4096
02-26 15:28:18.500: D/xuzhu(22728): base shader loading....
02-26 15:28:18.510: D/xuzhu(22728): texture shader loading....
02-26 15:28:18.510: D/xuzhu(22728): gray shader loading....
02-26 15:28:18.530: D/xuzhu(22728): color shader loading....
02-26 15:28:18.530: D/xuzhu(22728): onecolor shader loading....
02-26 15:28:18.540: D/xuzhu(22728): blurH shader loading....
02-26 15:28:18.560: D/xuzhu(22728): blurV shader loading....
02-26 15:28:18.560: D/xuzhu(22728): restore font
02-26 15:28:18.710: D/xuzhu(22728): restore image
02-26 15:28:20.870: D/xuzhu(22728): restore sprite
02-26 15:28:20.990: D/xuzhu(22728): restore game
02-26 15:28:20.990: D/xuzhu(22728): restore end
02-26 15:28:21.000: D/xuzhu(22728): prop/text_ko.txt....token.LoadFile() success
02-26 15:28:21.010: D/xuzhu(22728): text loading success.....prop/text_ko.txt. lastID:90007 num=3116
02-26 15:28:21.010: D/xuzhu(22728): XFacebook::GetRequestProfileImage: fbid=1097088886976908
02-26 15:28:21.010: D/xuzhu(22728): XSpot.cpp(100) ReloadProp():
02-26 15:28:21.010: D/xuzhu(22728):     PROP_WORLD == nullptr
02-26 15:28:21.010: D/xuzhu(22728): CrashHandler.cpp(48) SignalHandler():
02-26 15:28:21.010: D/xuzhu(22728):     crash! write dump.bin2



{"orderId":"GPA.1307-2459-7935-97507","packageName":"com.mtricks.caribe","productId":"inapp_cash00001","purchaseTime":1456723976120,"purchaseState":0,"developerPayload":"00DDD2336A824684BED75DA3B5BF0678","purchaseToken":"olnbliegcncnppgogboneplc.AO-J1OzygnbyLR4CJ5ovAEEDqDDyP3YFA21pqp4S1IWSzNX3w26GfTrqsWgcIIlOUKtidLEKwvMdPZsmLEcWlZ68FWHdK-yWtxfcm9nviYVVq5MuaTXY62fSLP9QrWCW0EH5-0eXAus1"}



		[2]	0x014c2f43 std::_Func_impl<struct std::_Callable_obj<class std::_Bind<1,void,struct std::_Pmf_wrap<void (thiscall XClientConnection::*)(class XDatabase *,class std::basic_string<wchar_t,struct std::char_traits<wchar_t>,class std::allocator<wchar_t> > const &,class std::basic_string<wchar_t,struct std::char_traits<wchar_t>,class std::allocator<wchar_t> > const &,class std::basic_string<wchar_t,struct std::char_traits<wchar_t>,class std::allocator<wchar_t> > const &,class std::basic_string<wchar_t,struct std::char_traits<wchar_t>,class std::allocator<wchar_t> > const &,unsigned long),void,class XClientConnection,class XDatabase *,class std::basic_string<wchar_t,struct std::char_traits<wchar_t>,class std::allocator<wchar_t> > const &,class std::basic_string<wchar_t,struct std::char_traits<wchar_t>,class std::allocator<wchar_t> > const &,class std::basic_string<wchar_t,struct std::char_traits<wchar_t>,class std::allocator<wchar_t> > const &,class std::basic_string<wchar_t,struct std::char_traits<wchar_t>,class std::allocator<wchar_t> > const &,unsigned long>,class std::_Ph<1> &,class std::_Ph<2> &,class std::basic_string<wchar_t,struct std::char_traits<wchar_t>,class std::allocator<wchar_t> > &,class std::basic_string<wchar_t,struct std::char_traits<wchar_t>,class std::allocator<wchar_t> > &,class std::basic_string<wchar_t,struct std::char_traits<wchar_t>,class std::allocator<wchar_t> > &,class std::basic_string<wchar_t,struct std::char_traits<wchar_t>,class std::allocator<wchar_t> > &,unsigned long &>,0>,class std::allocator<class std::_Func_class<void,class XClientConnection *,class XDatabase *> >,void,class XClientConnection *,class XDatabase *>::_Do_call(class XClientConnection * &&,class XDatabase * &&)	*






††pSocketSvr->Process							0.999  256219  0  0
††††XEWinSocketSvr::Process						  0.501  128416  0  0
††††††m_pUserMng->Process  0							.000  0  0  0
††††††XEWinSocketSvr::Process, listConnected		0.005  590  0  0
††††††XEWinSocketSvr::Process, listLogined			0.995  127774  0  0
††††††††XEWinConnectionInServer::Process			  0.000  44  0  0
††††††††††ProcessHeartBeat								0.227  10  0  0
††††††††††PumpPacket									0.136  6  0  0
††††††††††††ProcessPacket								  18.833  113  0  0
††XHttpMng::Process  0.000  102  0  0
††m_pGame->FrameMove  0.000  0  0  0






††pSocketSvr->Process					1.000  14813  0  0
††††XEWinSocketSvr::Process				  0.500  7409  0  0
††††††m_pUserMng->Process					0.000  0  0  0
††††††listConnected							0.002  16  0  0
††††††listLogined							0.997  7390  0  0
††††††††XEWinConnectionInServer::Process	  0.000  1  0  0
††††††††††ProcessHeartBeat						0.000  0  0  0
††††††††††PumpPacket							0.000  0  0  0
††††††††††††ProcessPacket						  1.#IO  15  0  0
††††††††destroy conn						  0.428  3161  0  0
††XHttpMng::Process  0.000  3  0  0
††m_pGame->FrameMove  0.000  0  0  0

03-31 14:57:35.514: D/softnyx(24758): handMessage: SoftnyxBuyItem
03-31 14:57:36.354: I/softnyx(24758): BuyItem
03-31 14:57:37.524: I/ActivityManager(24758): Timeline: Activity_launch_request id:com.mtricks.caribe time:33299150
03-31 14:57:37.574: I/softnyx(24758):  launchPurchaseFlow Success
03-31 14:57:37.574: V/Activity(24758): onPause com.mtricks.caribe.MyMainActivity@41b091f8
03-31 14:57:37.594: D/xuzhu(24758): nativeOnPause
03-31 14:57:37.594: D/xuzhu(24758): java stopBackgroundMusic
03-31 14:57:37.594: D/xuzhu(24758): XClientMain::OnPauseHandler()
03-31 14:57:37.594: D/xuzhu(24758): XGame::OnPause
03-31 14:57:37.624: D/RearGestureWrapper(24758): mSupportFingerKey:true,model:EF59S
03-31 14:57:37.624: W/ResourceType(24758): Invalid package identifier when getting bag for resource number 0x00000000
03-31 14:57:37.624: V/Activity(24758): onCreate com.pgman.inappbilling.pgmanstore_IAB_dlg@41e2f720: null
03-31 14:57:37.874: D/VegaPhoneWindowWrapper(24758): onWindowVegaAttributesChanged() :com.pgman.inappbilling.pgmanstore_IAB_dlg@41e2f720, frameRect:Rect(0, 0 - 0, 0), lp:WM.LayoutParams{(0,0)(fillxfill) ty=2 fl=#810502 pfl=0x8 fmt=-2 wanim=0x1030000}
03-31 14:57:37.874: W/VegaPhoneWindowWrapper(24758): backup flag: mWindowFlags:810502, attrs.flags:810502
03-31 14:57:37.874: I/PGMAN_SDK(24758): startSetup............ start 
03-31 14:57:37.874: I/PGMAN_SDK(24758): LoginConnect............ start 
03-31 14:57:37.884: I/PGMAN_SDK(24758): LoginConnect............ not SESSION_IN  
03-31 14:57:37.884: I/PGMAN_SDK(24758): SESSION_EXPIRY............ start 
03-31 14:57:37.884: V/Activity(24758): onStart com.pgman.inappbilling.pgmanstore_IAB_dlg@41e2f720
03-31 14:57:37.884: V/Activity(24758): onResume com.pgman.inappbilling.pgmanstore_IAB_dlg@41e2f720
03-31 14:57:38.284: I/ActivityManager(24758): Timeline: Activity_idle id: android.os.BinderProxy@41e2eef0 time:33299915
03-31 14:57:38.294: V/Activity(24758): onSaveInstanceState com.mtricks.caribe.MyMainActivity@41b091f8: Bundle[{android:viewHierarchyState=Bundle[{android:views={16908290=android.view.AbsSavedState$1@41908598}}]}]
