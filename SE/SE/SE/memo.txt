SE 리팩토링
{
	*XObjAct와 XAniAction이 나눠져있고 XBaseLayer와 LAYER_INFO가 나눠져있는등
	 현재 구조가 복잡하다. 아마도 게임쪽과 소스를 공유해서 쓰려다보니 이런구조가 된듯.
	*툴에서는 Dat와 Obj를 나눌필요가 없을듯 하다(object layer때문에 필요하려나)
	*일단 XAniAction은 어떤경우에도 공유되는것이 아니므로 XObjAct와 XAniAction은
	하나로 합친다.
	*LAYER_INFO와 XBaseLayer도 하나로 합친다.
	*XSprObj는 XSprDat를 참조하고 있고 XSprDat는 XAniAction을 가진다.
	*각 XAniAction들은 XBaseLayer들을 가진다.
	*코딩이 수월하도록 XAniAction과 XSprDat의 소스를 분리한다.
}

XKeyBase는 공유되는 데이타인데 만약 sprObj를 child로 두개이상 로딩했을경우 문제가 생김.

.565포맷으로 저장
.레이어 잠시 감춤(클릭도 안됨)
.클릭으로 다른 레이어 선택못하게
.우클릭 바닥 드래그로 이동/회전/확축되게
.키 더클클릭하면 편집창 뜨게
.이동/회전/확축 마우스로 했을때 소숫점 어느정도까지 잘라버리자
. 이미지레이어 선택되어 있으면 키보드로 움직일수 있게.
. ctrl-1,2누르면 이전액션과 현재액션 왔다갔다 할수 있게. 레이어 선택해둔것도 변하지 말게
. thumnail뷰에서 애니뷰로 드래그해서 내려놓은거 언두 되게
. 0프레임 액션은 플레이 아예 안되게
. 레이어 복사/참조
. 액션 복사/참조
. 트리구조의 레이어
. 타임라인뷰 세로스크롤
. 액션아이디 값 바꿀수 있게.
. 배경에 참조용 배경한장 깔고 이동가능 하게
. 확대했을때 변환축 클릭 안됨
. 변환축 드래그 쉽게 하기
. 오브젝트 픽셀로 픽킹해서 드래그 하지말고 별도의 핸들을 만들것.
. 이미지키 속성에 xml데이타를 붙여넣을수 있게 해서 OnDelegateDrawImageLayer()같은거에서 쓸수 있도록 한다.
  XML데이타는 spr을 로딩할때 미리 파싱해둔다.
. 이미지레이어 델리게이트 처리 방식(아래 "스톡게이지 케이스의 경우 처리는 방식"항목을 참조)
. 애니메이션 데이타를 SE에서 가져다 쓰기(아래 애니메이션 데이타를 SE에서 가져다 쓰기전략 항목을 참조)
. 다른레이어를 링크할수 있는 레이어
. 스프라이트가 없어도 액션 만들 수 있게.

	LDown코드도 리팩토링하고
	키카피를 다른레이어로도 할수 있도록.

16.05.12
 . png저장
16.03.25
 . 랜덤요소 적용
 . 0번키 자동으로 생성되던거 삭제
 . 
15.10.13
 . 100%뷰로 저장하지 않았을때 바운딩박스 잘못계산되던 버그 수정
 . 이벤트 생성에 스케일값 넣을수 있게 수정
 . 오브젝트레이어에 좌우반전 안먹던 버그 수정
 . 레이어 픽킹 확대되었을때 제대로 안되던 버그 수정
 . 액션번호 수정에서 액션이름 자동으로 들어가게
13.7.23
 . CreateObjKey에 지정된 플레이모드가 무조건 LOOP로 작동해서 수정함.

13.5.7
  . 애니메이션 뷰를 확대한채로 저장하면 바운딩박스도 확대되서 저장되는 버그 있음
    문제는 뷰를 다시 축소시켜 저장해도 바운딩박스는 다시 안줄어들음..
	임시로 뷰를 축소시켜저장하면 줄어들게 바꿔둠.
11.2.3
  . 스프라이트 이미지 교체할때 ADJ는 건드리지 않게.
11.12.14
  . 사운드키 안넣어지던 버그 수정.
  . 사운드키넣고 플레이하면 멈추던 현상 수정.

11.9.28
  . 쉬프트 누른채로 스프라이트를 썸네일로부터 드래그&드롭 하면 자동으로 이미지레이어가 추가된다
11.8.3
  . spr파일 직접 클릭으로 실행되는 기능 구현
11.7.27
  . adjust뷰에서 키 안먹던버그 수정
11.7.19
  . pos키 자동생성 추가
  . 키프레임뷰 현재 위치 자동포커스(스크롤)
  . 애니메이션뷰에서 키선택 및 이동 가능하게...
  . 어떤 오브젝트들을 드래그 해서 선택하고 이동시키고 하는 과정을 객체화 시켰음. XDragSelect
  . 언두시 제대로 복구 안되던거 수정
11.7.14
  . 패스키끼리 선연결
  . 패스 해제
  . 패스정보 세이브/로드. SPR버전 20으로 변경
  
11.7.12
  . 패스키의 삭제, 생성, 순서바꾸기
11.7.9
  . 기존데이타의 호환을 위해 단칸짜리 패스에 대한 처리를 함
  . 패스의 끝과 다른패스의 시작이 연결될수 있게 키를 id방식으로 바꿈
    잔에러를 없애기 위해 패스의 다음키를 실시간으로 찾으려 했으니 패스끼리 연결되는 구조를 하려면 불가능.
    그래서 블럭으로 키를잡아서 패스로 명시적으로 지정하면 서로 이중링크구조로 연결되게 함
11.7.7
 . PosKey의 보간을 패스방식으로 바꿈.
 . 스플라인 패스지원.
 . 스플라인상에서 전체 보간 지원.
11.7.6
  .  pos키 이동경로 볼수있게 됨
 11.7.5
  . 키와 키사이를 보간할때의 함수를 지정할수 있게됨
11.7.1
  . 이미지 툴팁에 이미지도 볼수 있게 수정
  . 툴팁에서 루아코드 볼수 있게 수정
11.6.30
  . CToken::CreateGetBlock()함수 다중 블럭({}) 지원되게 함. 테스트는 안해봄
11.6.29
  . 키 ID도 파일에 저장되게함. 이 아이디로 루아함수명 만들때 사용
    spr버전 18로 올라감
  . lua_tinker::member_isfunction함수 수정. 테이블이 없는채로 호출하면 다운됨
11.6.28
  . 키에 루아 붙일수 있게 함
  . XKeyImagePos/Rot 이런클래스들 싹 정리함
  . 아이캐치 루아로 동적으로 얼굴 바뀌게 구현함
11.6.21
  . 키 드래깅 선택 완성
  . CFrameView에서의 각종 복잡한 Mode를 정리함
  . ALT누르면 감속기능
11.6.20
  . 같은 레이어상에서 키카피
  . 도돌이표 표시 버그 수정
11.6.17
  . 툴의 뷰 레이아웃 교체
  . CDockablePane사용
  . 프레임뷰에 시간단위 눈금으로도 볼수 있게
11.6.14
  . 마술봉을 따라 파티클을 뿌리려고 했더니 
    더미레이어를 쓰는게 좋을거 같고, 
    더미레이어를 쓰자니 휠 확축지원이나 앵커 드래그가 아직 미완성이어서 그거 고쳤고
    더미레이어의 메인레이어에 on/off키도 만들었고,
    프레임뷰위에서 키생성할수 있는 기능까지 만들었다. 헉헉
11.6.3
  . 애니메이션 뷰도 확축지원되게 바꿈
  . 현재 마우스가 움직이고 있는 뷰를 포커스바꾸고 외곽선 칠함
11.6.2
  . GScale뺀 버전으로 다시 작성
    이에따라 스프라이트 버전이 15로 올라감
  . 뷰 확축기능 추가 
11.5.12
  . OpenAL+ogg버전으로 교체
11.4.22
  . png파일 드래그할때 키추가 여부를 묻는다
  . 저장시 체크아웃 안되어있는 에러를 잡아냄
11.4.12
  . 스프라이트를 애니메이션뷰로 드래그해서 키를 만들때 이미 그자리에 다른 이미지키가 있으면 삭제하고 넣는다
  . 드래그시에 드래그거리 나오게함
11.4.1
  . AdjustView에서 키보드로 adjust맞출수 있게
11.3.29
  . png끌어다 놓을때 이미 있는이미지등의 이유로 스킵이 되더라도 키는 추가되게
  . png다수 끌어다 놓을때 액션추가 안함으로 선택하면 현재액션의 키로 추가되게
    이 기능 언두 되게
  . tif 도 로딩되게 수정
11.3.25
  . 도돌이표 기능 추가
  . 액션별로 플레이루핑모드 추가
  . 이로인해 스프라이트 버전이 11->13으로 올라감
11.3.17
  . 레어사운드 로딩폴더 MakePath로 읽게함
  . XLOG는 Console뷰로도 출력.
11.3.16
  . 정렬된 이미지 잘라내기 기능 추가
11.2.25
  . 액션 삭제할때 커런트오브젝트액트를 잃어버려 죽는 버그 수정
  . png끌어다 놓을때 이미지와 adj까지 완전히 같아야 같은 스프라이트로 인정하게 바꿈
  . png다수를 끌어다 놓을때 액션을 추가하지 않는 옵션을 선택하면 현재 액션에 키가 이상하게 들어가는 문제 수정해야함.
11.2.17
  . GetToken()에서 맨 마지막 pCurr--부분의 버그. "endif\0"으로 끝나는 파일일경우 endif까지 읽고 포인터 증가를 하지않았던 문제가 있었기때문에 pCurr--를 계속해서 무한루프에 걸렸었다
11.2.15
  . 더미레이어 완료. 레이어 아이디추가 spr버전 11로 증가.
11.2.14
  . Adjust언두
  . 더미레이어 구현중
11.2.12
  . 맥스프레임 조절 언두
  . 액션값조정 언두(대입 함수 및 =오퍼레이터 구현)
  . 레이어 회전/스케일 언두
  . 스프라이트 삭제 언두
11.2.11
  . 언두시스템 구현중(액션삭제, 리두, 다중키이동)
  . XBREAK(EXP)매크로 구현. EXP를 스트링으로 만들려면 #EXP하면 된다 ㅋㅋ
11.2.10
  . 언두시스템 구현
  . 플레이 중간에서 레이어가 삭제되며 키도 같이 삭제되니까 XAniAction::m_itorKeyCurr이 0xfeeefeee로 깨지더라. 그래서 키삭제한후에 m_itorKeyCurr을 초기화 시켰다
  . XObjAct::DelLayer()를 private으로 바꿨다. 레이어를 삭제하려면 XSprObj::DelLayer()를 써야한다
  . 레이어 삭제언두시 원래 레이어 위치로 돌아가도록 수정
11.2.9
  . 언두의 행동들
    . 애니메이션뷰
      # 이동키 생성
      # 레이어의 #이동/회전/스케일
    . 프레임뷰
      # 키의 이동/#삭제/수정(다중선택언두도 지원)
      # 레이어 삭제
      # 애니메이션 속성(MaxFrame같은) 변경
      # 마우스로 MaxFrame변경
    . adjust뷰
      # 스프라이트의 이동/
    . 썸네일뷰
      # 스프라이트의 추가/삭제
    . 액션리스트뷰 
      . 액션을 바꿀때 언두를 클리어하는걸 개선.
        . 액션을 삭제하고 다른 액션을 선택했다가 언두를 하면 삭제가 복구가 안되는 치명적 문제
        . 액션포인터를 쓰지말고 아이디를 써서 액션을 삭제하더라도 포인터를 잃지 않도록.
        . 액션을 선택하는 행동도 언두로 추가
        
  . 언두 메커니즘
    . 어떤 행동을 저지르기전 그것의 역행동을 정의하여 언두스택에 넣는다.
    . 언두를실행하면 스택에서 역행동을 하나 꺼내 실행한다.
    . 그 역행동을 실행취소 스택에 넣는다.
  . 키 삭제. 키값 백업, 
  . 언두시스템 구상
11.2.8
  . xLIB 매뉴얼 작성 완료
  . XE 네임스페이스 코드 작성. pc버전에서 초기화가 간편해짐
11.2.7
  . 저장하기전 키가 없는 레이어는 삭제시킴
  . defineAct.h를 스크립트로 읽게..
  . se.ini와 더불어 워킹폴더를 지정하도록...
11.1.31
  . xLIB 폴더 체계 확립함. 기존 GameLib시리즈들과 완전 분리
11.1.27
  . 회전축 보이기/감추기 옵션
  . 이동/회전/각도키의 키값 수정기능이 추가.
  . 애니메이션뷰에 마우스커서 좌표가 표시됨
11.1.25
  . DXUT.obj : error LNK2019: __imp__InitCommonControls@0 외부 기호(참조 위치: "long __stdcall DXUTInit(bool,bool,wchar_t *,bool)" (?DXUTInit@@YGJ_N0PA_W0@Z) 함수)에서 확인하지 못했습니다.
	C:\direct3d\dxut_test\Debug\dxut_test.exe : fatal error LNK1120: 1개의 확인할 수 없는 외부 참조입니다.
	#pragma comment(lib, "comctl32.lib") <- 위 링크에러가 나오면 이걸 넣을것
  . 피씨 버전 완성
  . 툴에서 픽킹계산이 허접이라 다시 직관적으로 바꿈. DRAW했을때랑 같은 매트릭스를 써서 하는방법으로 교체

11.1.24
  . 피씨 버전 포팅하면서 스프라이트의 알파값이 안먹는 버그로 개고생. 원인은 픽셀쉐이더에서 
	color = tex2D( SpriteSampler, IN.TexCoord0 );
	color.a = fOpacity * color.a;   <- color.a값도 반영해줘야 하는데 fOpacity값만 그대로 입력해서 알파값이 모두 사라졌던게 문제 아 ㅅㅂ
11.1.21
  . 확축채널 구현함
  . 이미지레이어의 스프라이트를 선택하면 adjust창에 보여지게 함
  . XERROR( "LayerMove 타입이 아니다" ); 에서 1>c:\project\se\se\se\sprobj.h(194) : error C2001: 상수에 줄 바꿈 문자가 있습니다.
	1>c:\project\se\se\se\sprobj.h(194) : fatal error C1057: 매크로 확장에서 예기치 않은 파일의 끝이 나타났습니다.
	이 에러가 뜨면 그 파일이 UTF-8로 저장되어서 그렇다
  . Key에서 레이어포인터를 직접 가지고 있던 문제 수정
11.1.19
  . 스프라이트에 원본파일정보가 저장됨. 스프라이트 버전 10으로 올라감
  . 스프라이트에 액션이 없어도 로딩되도록 수정(폰트같은거 용도)
  . "연속된 이미지 읽기"기능이 추가되었음.
  . 팀칼라 변환용 기능 추가됨
11.1.17
  . 액션리스트 스크롤되게
11.1.12
  . Accelerator로 '1' '2'키를 등록시켜놓고 에디트박스에 값을 입력할때 1,2키는 안먹히는 증상이 있다. 
    해결책: 에디트박스에 SetFocus/KillFocus가 될때 g_bEditing플래그를 전환시키고 MainFrame의 PreTranslate.....에서 edit==true면 CFrameWndEx::PreTranslateMessage를 실행하지 않고 0을 리턴하게 했다
11.1.11
  . adjust값을 마우스 드래그하여 조정할수 있게 함.
  . 현재프레임을 표시하는 파란선을 넓은 띠로 바꿈
  . 최대프레임수를 수정할때 직접입력방식이 추가
  . 썸네일뷰에 스프라이트 인덱스 표시
  . 키 툴팁 보이게 함
  . 메인프레임 초기크기를 더 크게 늘임
11.1.10
  . event key(create obj)에 생성할 오브젝트 id를 넣을수 있게 되었다.
  . 좌표축 고정 기능을 넣었다
11.1.7
  . createobj key 액션번호도 넣을수 있게 수정
   이에따라 spr파일 버전이 9로 올라감
  . 부모 XSprObj가 멈추면 자식들도 애니메이션을 멈추도록 수정
11.1.6
  . 선택한 스프라이트의 adj값을 0으로 초기화시키는 기능 들어감
  . 액션카피 추가
11.1.5
  . 지포스 GTS450의 경우 CAPS.POW2가 NO로 나오는데도 2^가 아닌 텍스쳐를 생성하지 못한다. 그래서 무조건 2^로 텍스쳐를 생성하도록 바꿨다
  . 프리프때 쓰던 익셉션핸들러가 작동하지 않는다 윈7이라서 그럴까?
11.1.4
  . 릴리즈로 빌드했는데도 d3dx9d_42.dll을 찾는문제. 릴리즈 링크옵션에서 d3d**.lib를 링크시킬때 d3d9d.lib d3dx9d.lib등 d가 붙은버전(디버그버전)으로 링크해서 그렇다
  . 그래도 어떤컴에선 d3dx9_42.dll을 찾는다 이파일이 어디쓰는건진 모르겠지만 directx최신버전을 깔아주면 해결은 된다. 아마도 2009년 August버전의 sdk를 써서 그전에 나온 directx라면 이런에러가 나오는듯하다
  . 맥에서 d3d를 쓸땐 텍스쳐의 가로사이즈를 pow2(2의승수)로 맞추지 않아도 되지만 다른사람컴에선 이걸 맞춰줘야만 한다. caps.texturecaps.pow2에 그항목이 있음
11.1.3
  . 이벤트레이어 구현함
  . XKeyEvent에는 한가지 타입의 이벤트만 들어가도록 했고, 만약 같은 타이밍에 여러가지 타입의 이벤트가 발생되어야 한다면 한자리에 키가 여러개 생겨야 한다
    그렇기 때문에 FrameView에서 겹쳐있는 키를 효과적으로 선택할수 있는 인터페이스가 필요해진다
  . 일단 CreateObj Event에서 오브젝트 id는 reserved만 하고 게임에선 하드코딩으로 생성하게 하자. 후에 필요해지면 툴에서 오브젝트 아이디 스크립트를 읽어서 툴에서 입력할수 있게 바꾸자
10.12.30
  . 다른액션을 선택했을때 이전 액션의 선택된 레이어가 클리어 되지 않았던 문제 수정
  . 회전채널 아이폰으로 이식
  . 회전축 변경기능으로 인해 스프라이트 버전 8로 올라감 
  . adjustView에 size, adj정보 표시
10.12.29
  . 회전축 변경가능 기능 추가
  . 회전축 변경가능에 대한 픽킹계산방식 수정
  . 1, 2키 기능 추가
  . 회전키 저장 기능
10.12.27
  . 회전채널방식을 상대각도키방식에서 누적절대각도 방식으로 바꿨다.
  . 회전축 바꿀수 있 구현중
10.12.24
  . 회전 채널을 구현함
  . 첫프레임에 회전키가 없을때 중간프레임에 회전키를 넣었을경우 처리가 애매하다
    . 방법
      1. 플레이중 프레임이 첨으로 돌아오면 무조건 레이어를 클리어 시켜서 회전값이 0이되도록 한다.
      2. 0프레임에 수동으로 각도0짜리 키를 넣기쉽게 만들어준다.
      3. 새로 생성한 중간프레임의 회전키 앞에 키가 없다면 자동으로 0번프레임에 각도0짜리 회전키를 넣어준다.
  . 회전시 원형인터페이스를 그려줘야 함.
  # 소숫점 아래 각도를 반올림하는부분이 절대각도와 상대각도의 싱크가 맞지 않는일이 있다.
  . 회전모드 툴바 아래로 내려올것
  # 회전 저장기능 구현     
  # 자동으로 0프레임에 키를 넣어주는게 맞는듯함
  . 뛰어내리는 애니를 구현하려면 세밀하게조정해야 하므로 확대기능 반드시 필요
  # 1,2키로 한프레임씩 이동하는기능 필요
  10.12.23
  .	액션리스트창에서 액션추가 기능 들어감
  . 썸네일창에서 선택된 스프라이트들을 액션으로 추가하는 기능 들어감.
10.12.22
  . 액션이름과 아이디를 편집할수 있게 되었음. 맥쪽의 common폴더의 defineAct.h를 공유
  . #define이 들어있는 .h파일을 UTF-8로 저장하면 한글바로 뒤의 #define 이 인식하지 못하는 문제가 있다. Korean(EUC,949)코드로 저장할것
  . 프로젝트가 유니코드모드일때 한글문자열을 사용하는 소스코드는 한국어949코드페이지로 저장되어야 _T("")매크로가 제대로 먹는다. UTF-8같은걸로 소스가 저장되어
    있으면 한글변환이 안된다
10.12.21
  . 오픈한 spr파일의패스로 spr을 읽거나 저장하도록 수정
  . 샘플캐릭터 아이폰에 올려봄
  . 키에 레이어 포인터가 들어갔던 버그 수정  
10.12.20
  . 스프라이트 플립과 알파블렌딩, screen모드 출력기능을 만듬
  . 이펙트채널이 들어간 버전을 아이폰으로 이식함
  . 쉐이더로 알파블렌딩을 원할때 알파블렌드 기능을활성화 시키려면 두가지 방법이 있다.
    . SetRenderState( 알파인에이블 ), SRCBLEND, DESTBLEND 로 켜는 방법
    . 쉐이더 코드에서 AlphaBlendEnable = TRUE, SrcBlend, DestBlend 로 하는 방법 
  . 아이폰쪽 XSurfaceOpenGL쪽 코드에서 Adjust관련 버그가 있었다. Draw시에 x += m_nAdjustX를 하고 있었는데 이걸 할필요가 없다. 버텍스버퍼를 만들때 이미 adjust를 반영하여 버텍스를 만들었기 때문
10.12.17
  .  스프라이트 플립기능과 알파블렌딩 기능을 만듬
  . 3d를 2d로 쓸때 x,y,z중 z는 사용하지 않는데 Y축 회전을시키면 z에 값이 생겨버려서 출력이 안되는 문제가 있음 그래서 쉐이더를 사용했고 z를 강제로 0으로 맞춰줌
10.12.16
  . Direct2D를 버리고 Direct3D로 뒤엎음
  . DXUT의 스왑체인 기능을 이용하면 좋은데 dx10만 지원한다. 맥의 패러럴즈 스튜디오는 dx9만 지원해서 못씀
  . Cola에 썼던 d3dapp.cpp를 재활용함
10.12.15
  . Popup메뉴의 UPDATE_COMMAND_UI메시지가 발생하지 않을때. TrackPopupMenu()를 호출할때 this로 하지 말고 AfxGetMainWnd()로 해라
  . Image Effect채널 만듬. 알파블랜드는 구현했으나 Flip과 Screen찍기 모드등은 Direct2D에서 지원하지 않아서 Direct3D로 교체 해야 함
10.12.14
  . CComboBox구현시 상속받아 쓰는게 아니라면 Owner Draw를 꺼야 한다. 그리고 Has String을 켜야 한다
  . Image Effect채널 구현을 위해 이미지 속성 다이얼로그창을 구현
10.12.10
  . 게임엔 _UNICODE디파인을붙이고 게임내에서 쓰는 모든 스트링은 utf8버전인 CHAR(char), LPCSTR(const char*)를 쓴다
  . 리소스파일에 저장된 스트링은 UTF16-TCHAR-WCHAR버전으로 저장되고 CToken에서도 TCHAR(unichar)로 읽은후 CToken내에 저장할때는 LPSTR(UTF8)로 저장해둔다. 스트링을 비교할때는 m_Token == "set한글"(UTF8) 식으로 비교하면 된다
  . 리소스파일내에 저장된 파일명등의 토큰은 UTF16-TCHAR-WCHAR로 저장되어 있으므로 Load( LPCSTR )함수를 호출하기전에 UTF8로 변환시켜쓴다. 변환은 NSString을 이용한다
10.11.25
  . FormView는 OnKeyDown메시지가 안들어온다. 덩달아 MainFrame까지 안들어오더라. PreTranslateMessage를 만들어 처리해야 한다.  
10.11.24
  . 메뉴에 단축키 지정을 했는데 단축키가 먹지 않는 문제 발생. 심지어는 엑셀레이터에서 해당단축키를 지웠는데도 계속 남는 현상.
    원인은 CSEApp::InitInstance()에서 CleanState()를 하지 않아 발생한문제.
  . 뷰에 draw를 했는데 세로로 몇도트 어긋나는현상. 원인은 리소스에디터에서 다이얼로그내의 파란선을 끝까지 움직여 줘야 한다.   
10.11.19
  . 도킹윈도우를 생성시켰는데 일반윈도우가 하나생기고 프레임에 도킹된 윈도우가 하나더 생기는 현상이 있었다.
    원인은 도킹윈도우에 붙이는 Dialog의 속성중 style이 popup으로 되어있어서였다. 그래서 child로 바꿈. 그리고 테두리속성도 없앰.  
10.11.18
   . View를 계속 렌더링하기 위해 CSEApp::OnIdel()에서 뷰의 Draw를 호출하게 했다. 그러나 OnIdle이 마우스가 움직일때만 호출이 되었다. 해결책은 
	BOOL CSEApp::OnIdle(LONG lCount)
	{
		if( GetAnimationView() )
			GetAnimationView()->Draw();
		CWinAppEx::OnIdle(lCount);		<- 이부분을 따로 불러주고
		return TRUE;							<- 항상 TRUE를 리턴하게 하면 해결된다
	}
10.11.17
  . png드랍해서 스프라이트와 액션/프레임 추가한후 화면에 찍는거 까지 함
  . 그러나 문제발생. 다른 View의 RenderTarget에서 생성된 D2D1Bitmap은 또다른 RenderTarget을 사용하는 뷰에선 쓸수 없음. 젠장
  . ThumbView에선 스프라이트 리스트의 모든 스프라이트 D2D1Bitmap을 가지고 있는걸로 하고 다른뷰는 각자 필요한 만큼의 비트맵을 가지고 있게 해결하자
  . OninitialUpdate()가 두번씩 불리는 현상있음. 원인모름. 그래서 렌더타겟생성부를 OnCreate로 옮김
     

* 만들어야 할 기능
 # 전체 프레임 조절 및 그에따른 스케일링
 # 키 멀티 셀렉트
 # 영역으로 멀티키 셀렉트
 # 오브젝트 레이어 pos 추가
 # 레이어 추가(이미지,오브젝트) 버튼
 # 키 카피
 # 쉐도우키 만들기
 # 선택한 키들만 스케일링 하는 기능(쉐도우 기능 이용)
 # 레이어 순서바꾸기
 # 액션 삭제기능
 # 스프라이트 삭제기능
 # 스프라이트 멀티선택 가능
 # 이펙트채널( 상하좌우 플립, screen, alpha, etc.... )-이미지레이어에 속함
 # 이미지레이어에 스프라이트 사라짐 키 구현(깜빡거리는 스프라이트 구현에 사용). 사라짐속성을 이펙트레이어에 통합시켜도 괜찮을듯
 . 현재 커서위치 이후/이전의모든키 선택 기능
 . 공백삽입기능( 키 사이를 일괄적으로 벌려야 할때)
 # 전체프레임 크기 다이얼로그로 직접 입력 기능
 # 액션이름 편집 기능
 # 회전, 확/축 키 구현-이미지레이어에 속함
 . 윈도우 사이즈 변경시 재실행해도 이전 위치를 기억하는 기능
 . 저해상도 버전 저장기능(자동저장, 미리보기 기능 지원)
 # createObj로 spr을 불러올때 다른액션번호로도 불러올수 있는기능
 # 첨부터 obj, sound레이어 넣지 말것
 # 이벤트 레이어(타점 같은속성) 구현
 . 충돌범위 편집-프레임별로 가능하도록
 . 맥스처럼 툴아래 바에서 좌표,각도,스케일값을 직접 입력할수 있도록
 # adjustview에서 크기,adj값등의 정보를 표시하기
 . 팔레트 정보를 읽어서 팔레트값만바꿔서 색깔다른 스프라이트 만들어 낼수 있도록
 . 이벤트레이어를 모든걸 통합할수 있는 스크립트 레이어로 전환
   . 이벤트키가 실행될때 해당 스크립트가 실행되는 방식. 루아 아이폰 이식?
 # 툴바에 X,Y,XY버튼이 있어서 마우스이동등의 행동을 할때 좀더 쉽게 할수 있도록
 .  각 뷰에 툴바 구현
 
 
 * 스프라이트에서 루아의 활용
 사례1: 동적으로 캐치아이의 장군얼굴을 교체
 {
	방법1: 모든 키는 루아스크립트를 가질수 있게 한다
	{
		XObjGeneral:스킬사용() {
			new XSprObj( "eye_catch.spr", this );
		}
		XKeyCreateObj::Execute( pSprObj ) {
			스프라이트 이름 = NULL;
			if( 루아가 있는가 ) {
				if( 루아->함수가 있는가( "GetSprName" ) )
					 스프라이트 이름 = 루아->콜<const char*, XBaseObj*>( "GetSprName", pSprObj->GetParent() )
				else
					스프라이트이름 = GetszSprName()
			}
			AddObj( 스프라이트이름 );
		}
		XKeyCreateObj키에 GetszSprName()을 재정의한 루아를 만든다
		function GetSprName(obj)
			local gen = CastGeneral(obj)		// 캐스팅을 하는 방법
			local id = gen:GetGeneralID()
			if id == GEN_CHERABARA then
				return "eye_cherabara.spr", 1		// 다중리턴을 하는방법
			else if id == GEN_ROMBIT then
				return "eye_rombit.spr"
			end
		end
		function GetIDAct(obj)	
			--위 코드와 같은거..		// 이방식은 진짜 삽질이군
		end
		// SprObj생성을 모두 루아에게 맡기는 방법
		XKeyCreateObj::Execute( pSprObj ) {
			pSprObj = NULL;
			if( 루아가 있는가 ) {
				if( 루아->함수가 있는가( "CreateSprObj" ) )
					 pSprObj = 루아->콜<XSprObj*, XBaseObj*>( "CreateSprObj", pSprObj->GetParent() )
				else
					pSprObj = AddObj( GetszFilename() )
			}
			m_pSprObj = pSprObj;
		}
		// 이방법은 스크립터한텐 개념이 좀 어려울수 있지만 SprObj의 포인터를 직접 건드릴수 있으므로 활용도는 높다
		function CreateSprObj(this,obj)
			local gen = CastGeneral(obj)		// 캐스팅을 하는 방법
			local id = gen:GetGeneralID()
			if id == GEN_CHERABARA then
				sprobj = this:CreateSprObj( "eye_cherabara.spr", 1, RPT_LOOP );
				return sprobj 
			else if id == GEN_ROMBIT then
				return "eye_rombit.spr"
			end
		end
	}
	방법2: 스크립트 레이어를 따로 갖는 방법
	{
		동적제어를 할 스크립레이어를 추가한다.
		CreateObj레이어의 CreatObj키를 얻어 m_pSprObj를 교체해준다.
		장점은 개발이 단순해지고 스크립트를 처리하는 부하가 스크립트레이어에만 한정된다.
		그러나 레이어의 우선순위에 따라그 조작할 키가 실행되기 전일수도 있고 후일수도 있어서 애매해진다.
		게다가 후에 제어한다고 해도 조작할키에서 이미 new XSprObj()를 해버린상태기때문에 비효율적이다
		결론은 스크립트레이어를 사용한다면 키를 조작할 용도로는 곤란하고 게임내 오브젝트의 어떤 흐름을 제어할때만 유용할듯 하다
	}
	결론: 2가지 방법다 사용한다. 용도가 다르다.
	{
		1. 모든 키에 루아가 붙을수 있는구조
			각 키의 동작을 동적으로 제어할때 사용
		2. 별도의 스크립트레이어가 추가(트랜스폼키를 가질수 있다)
			SprObj의 부모obj를 제어할때 사용(탱크포격시 폭발오브젝트 생기는것도 이걸로 제어될듯)
	}
 }
 사례2: 나이팅게일의 애니메이션중 오브젝트에게 특정방향으로 이동 명령전달
{
	스크립트 레이어를 추가해서 파티클을 뿌리고 난후 시점에 obj의 dx,dy를 바꾸는 명령스크립트를 넣으면 될듯하다
	function Execute( obj )
		obj:GoFront()
		--obj:GoBack()
	end
	XKeyScript::Execute( pSprObj )
	{
		XLayerScript *spLayer = GetLayer();		// XLayerMove의 트랜스폼들을 루아내에서 쓰기위해 같이 넘겨줌
		pLua->Call<void, XBaseObj*>( "Execute", pSprObj->GetParent(), spLayer );
	}
}
기타
	키별로 혹은 레이어별로 m_pLua가 모두 분리되어있으면 전역변수 공유도 힘들고 퍼포먼스 측면에서도 안좋으니
	에디팅은 따로 하더라도 저장하거나 로딩할때 하나로 합쳐서 하나의 루아스레드로 만들자
각 키별로 어떤 핸들러가 만들어 질수 있나
	공통
		function Execute( this, obj, sprobj, layer )
		end
	이미지키: 
		function GetSprIndex( obj )
			return <Sprite index>
		end
	이동키:
		functioin Execute( this, obj, sprobj, layer )
		XKeyPos::Getx()
		XKeyPos::Gety()
		XKeyPos::GetInterpolation()
		XBaseObj::GetSprObj()
		XBaseObj::OnXXXXX시리즈()
		XSprObj::모두
		XLayerMove::Get(Set)XY()			--보간된 현재좌표
		XLayerMove::Get(Set)RotateXYZ()	--보간된 현재 회전각도
		XLayerMove::Get(Set)ScaleXYZ()		--보간된 현재 스케일값
		XLayerMove::Get(Set)Alpha()		--보간된 현재 알파값
		XLayerMove::Get(Set)DrawMode()
		XLayerMove::GetSlerpTranslate()	-- 레이어 이동파트 현재 slerp값
		XLayerMove::GetSlerpRotate()		--
		XLayerMove::GetSlerpScale()		-- 
		end
	
GEN_CHERABARA=1
GEN_ROMBIT=2
gen={}
function CastGeneral( obj )
	return gen
end
function gen:GetGeneralID()
	return 2
end
	
key1169547={}
function key1169547:CreateSprObj( sprName, idSprObj, sprObj, obj )
	local gen = CastGeneral(obj)			--obj를 장군형으로 바꿈
	local id = gen:GetGeneralID()			--장군아이디 얻음
	if id == GEN_CHERABARA then
		return sprObj:AddSprObj( "eye_cherabara.spr", idSprObj ); 
	end 
	if id == GEN_ROMBIT then
		return sprObj:AddSprObj( "eye_rombit.spr", idSprObj ); 
	end
end
function key1169547:Execute()
end

전체길이 100프레임가정. 20프레임단위로 키.
현재프레임값을0~1값으로 변환(t) = 현재프레임 / 전체프레임(100)
현재/전체프레임에 대한 가속보간값 = xiHigherAccel( t )


CatmullRom( v0, v1, v2, v3, s )


키 여러개를 잇는 스플라인의 전체 보간의 경우, 예를들어 키5개짜리의 1초짜리 스플라인인데 보간방법은 첫프레임에 빠른속도로 이동하다 
  마지막에 급격이 느려지는 움직임이라고 하자. 그렇다면 시작과 동시에 현재 x,y위치는 키4번을 이미 지나있는 상황일수도 있다.
  이런 상황이 있을수 있기때문에 스플라인 움직임이 시작되기전에 이미 레이어는 모든 스플라인의 키들의 위치를 가지고 있어야 한다.
구현방법:
1.스플라인이 시작되는 첫번째 키가 실행될때 연결된 모든 스플라인키의 정보를 레이어에게 전달한다.
{
	레이어에 스플라인 보간 플랙이 켜지면 적절한 보간함수에 의해 매프레임보간값을 얻고 그 보간값이 실제 스플라인에서 어느위치여야
	하는지 계산해서 좌표를 이동시킨다.
}
2.게임에선 어차피 정적데이탄데 미리 레이어가 스플라인 정보를 다 갖고 있어도 되지 않을까?
	2.2.만약 한 레이어에서의 움직임이 끊어진 다수 스플라인형태라면?
	{
		그렇다면 각스플라인 시작키가 자기 꼬리들을 레이어에 그때 그때 전달하는게 깔끔하긴 할듯
		어차피 게임쪽에선 시작키랑 그뒤로 몇개까지가 스플라인인지 정보만 전달하면 되니까 최적화문제도 없을듯. 대신 레이어에서 키리스트에 억세스 할수 있어야 한다.
	}
3. 스플라인이 아니고 선형패스 이면?
{
	레이어에게 '스플라인'정보가 아니고 '패스' 정보를 넘겨준다는 개념이어야 함
	지금처럼 키두칸사이 보간도 '짧은패스'라는 개념으로 생각하면 일관되게 구현될듯하다.
}
'패스'에 속한 키들은 키가 실행될때 암것도 안하고 지나쳐야 할듯
키간에 쉽게 옮겨다닐수 있게 XBaseKey안에 XBaseKey *m_pNextKey를 넣어놓고 바로 억세스 되게 써야할듯.
/////////////////////////////////////////////////////////////////////////////////
스톡게이지 케이스의 경우 처리 방식
{
	기본적으로 게이지bg/게이지(32단계중하나)/스톡이미지(5개중하나)/번호(3개중하나)의 레이어로 구성
	1. 스톡이미지별로 액션 5개를 만들어둔다.
		.5개 액션중에 하나를 골라서 플레이 하면 된다.
		.게이지와 번호는 델리게이트로 바꿔준다.
		.어차피 게이지를 하드코딩으로 스프라이트 인덱스를 쓰고 있는데 이게 무슨 의미?
		.한액션에 수정이 일어나면 레이어 복사등의 기능을 지원해서 다른액션에 복사해준다.
	2. 액션은 하나만 만들고 모두 델리게이트에서 커스텀 처리한다.
		.이걸 하려면 스프라이트 인덱스방식에서 아이디방식으로 바껴야 한다.
		.델리게이트에선 스프라이트 아이디값으로 조작해야 한다.
		.만약 그림이 바뀌는 애니메이션이 있다면? 스톡의 이미지가 애니된다든가.
		 -이미지 첫키를 기준으로 그다음 아이디는 오프셋방식으로해서 자동화 되도록..1,3,5,6이었는데 11,13,15,16 으로 자동으로 바뀌게
		.여전히 스프라이트 아이디값은 하드코딩되는 부분이 있다.
	3.액션하나에 스톡색별로 레이어를 여러개 만들어두고 안쓰는 레이어는 꺼두고 플레이
		.한액션안에 다들어있으므로 스톡이외의 레이어가 변형되어도 관리가 쉬워짐
		.한 이미지레이어안에 이미지 채널이 여러개 들어갈수 있으면 더 실용적일듯
		 -스톡이미지별로 이미지채널을 여러개 만들어두고 채널만 끄면 되니까.
		.여전히 꺼야할 채널번호는 하드코딩되어야 하는 단점이 있다.
		.링크액션기능을 추가. 액션인데 직접 값을 가지지않고 다른액션을 링크만하고 추가데이타만 몇개 더 가지고 있는 액션
		 - xml데이타를 가지고 있을수 있게 해서 켜야하는 채널번호를 툴에서 입력하도록.
		 - 루아로도 되지만 프로그래밍이라는 부담감이 있다. 실수로 에러가 날수도 있고.

	#결론: 2번과 3번을 혼합할수 있으면 편해지겠다.
}

//////////////////////////////////////////////////////////////////////////////////
애니메이션 데이타를 SE에서 가져다 쓰기전략
{
	*케이스: 스톡바에서 중간스톡이 빠졌을때 뒷쪽스톡이 앞쪽으로 당겨지는 애니메이션을 SE로 만들기
		.방법1:1번스톡이 빠지고 2~7번스톡이 앞쪽으로 당겨지는 애니메이션부터
		       6번이 빠지고 7번이 당겨지는 애니메이션까지 케이스별로 다 만들어 둔다
		{
			.존나 무식하지만 디자이너가 작업하기엔 직관적이다.
			.프로그래밍 작업도 케이스별로 갖다쓰기만 하면 되므로 간단하다.
			.수정을 해야할땐 모두 고쳐야 하기때문에 불편해진다.
			.슬롯에 자물쇠 채워진경우는 어떻게?
		}
		.방법2:스톡한칸만 당겨지는 애니메이션을 만들어 프로그램에서 연결해 붙이기
		{
			.한칸만 애니메이션 작업을 해야하기때문에 전체를 놓고 작업을 할수없어 직관적이지 않아 디자이너가 불편할듯(좌우 여백을 고려해가며 해야하므로)
			.프로그래밍으로 케이스별 수작업 코딩이 약간 들어가야함
			.단순 보간움직임이면 굳이 SE로 할필요도 없이 프로그래밍으로 하는게 더 간단할수도...
			.
		}
		.방법3:예제로 케이스 한개로 만들어만 두고 프로그래머가 예제에서 원하는 부분의 애니메이션값만 뽑아 쓰는 방법
		{
			.예를들어 2번스톡빠지고 3~7번이 당겨지는 애니메이션을 디자이너가 예제로 만들어두면
			 프로그래머는 3번더미가 움직이는 값만 뽑아서 방법2처럼 프로그래밍한다.
			.디자이너에게 가장직관적이고 힘이 덜들어간다.
			.프로그래밍이 많이 들어간다.
			.
		}
	#결론: 일단은 그냥 하드코딩으로 하고, 장기적으로 3번으로 가는게 좋을듯하다.
}







			const auto typeChannel = pKey->GetSubType();
			switch( typeChannel )
			{
			case xKTS_MAIN: {
				auto pKeyObj = SafeCast<XKeyCreateObj*>( pKey );
				if( pKeyObj ) {
					auto pLayer = SafeCast<XLayerObject*>( pKey->GetspLayer().get() );
					if( pLayer ) {
						const float fViewMaxFrame = pLayer->GetmaxFrame();
						auto vLT = pKey->GetvDrawPos() + XE::VEC2( 0, 5 );
						const XE::VEC2 vSize( fViewMaxFrame * ( fWidthPerFrame ), KEY_HEIGHT - 10.f );
						XE::FillRectangleSize( vLT, vSize, XCOLOR_RGBA( 0, 0, 255, 128 ) );
					}
				}
			} break;
			case xKTS_POS: {

			} break;
			case xKTS_EFFECT: {

			} break;
			case xKTS_ROT: {

			} break;
			case xKTS_SCALE: {

			} break;
			default:
				XBREAKF( 1, "알수없는 채널타입:type=%d", typeChannel );
				break;
			}


{
  _Wptr=weak_ptr 
    {
	  m_spAction=shared_ptr 
	    {
		  m_pSprDat=0x08f146f0 m_ActID=99 m_szActName=0x08d0fb48 "대기" ...
		} [14 strong refs, 1 weak ref] [default] m_pSprObj=0x0891bb10 m_listLayer={...} } [1 strong ref, 1 weak ref] [default] }


{_Wptr=weak_ptr {m_spAction=shared_ptr {m_pSprDat=0x08f9d188 m_ActID=99 m_szActName=0x08953468 "대기" ...} [14 strong refs, 1 weak ref] [default] m_pSprObj=0x08f6d780 m_listLayer={...} } [1 strong ref, 1 weak ref] [default] }
weak_ptr {m_spAction=shared_ptr {m_pSprDat=0x08f9d188 m_ActID=99 m_szActName=0x08953468 "대기" ...} [14 strong refs, 1 weak ref] [default] m_pSprObj=0x08f6d780 m_listLayer={...} } [2 strong refs, 1 weak ref] [default]
weak_ptr {m_spAction=shared_ptr {m_pSprDat=0x08f9d188 m_ActID=99 m_szActName=0x08953468 "대기" ...} [14 strong refs, 1 weak ref] [default] m_pSprObj=0x08f6d780 m_listLayer={...} } [1 strong ref, 1 weak ref] [default]
weak_ptr {m_spAction=shared_ptr {m_pSprDat=0x09188f70 m_ActID=99 m_szActName=0x0914ea98 "대기" ...} [14 strong refs, 1 weak ref] [default] m_pSprObj=0x0910da20 m_listLayer={...} } [2 strong refs, 1 weak ref] [default]

speed0.1
  3.0frame => =3/6 => 30/60 => 0.5sec
speed0.2
  0.5sec => 12max*0.5 => 6frame
  6frame => 6/12??? => 0.5sec

  3.0 => 5.0
speed0.1
  1초 => 6프레임
  2초 => 12프레임 => 
  6 => 1.0sec
  12 => 2.0sec
  (60*0.1)=6frame => 초당 프레임
  12 / 6 = 2.0
  9 => 
  9 / 6 = 1.5
speed0.2
  12 => 1
  24 => 2
  (60*0.2)=12 => 초당 프레임.
  1초 => 12프레임
  2초 => 24프레임
  24 / 12 = 2.0
  1.5 => 12 * 1.5 => 18

  0.25초 => 3프레임